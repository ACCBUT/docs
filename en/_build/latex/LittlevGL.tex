%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{LittlevGL Documentation}
\date{Jun 12, 2019}
\release{6.0}
\author{Gabor Kiss-Vamosi}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


Some text and flags to select language.


\chapter{Get started}
\label{\detokenize{get-started/index::doc}}\label{\detokenize{get-started/index:get-started}}\label{\detokenize{get-started/index:welcome-to-littlevgl-s-documentation}}\begin{itemize}
\item {} 
lvgl on GihHub

\item {} 
example projects

\end{itemize}


\section{Live demos}
\label{\detokenize{get-started/live-demo::doc}}\label{\detokenize{get-started/live-demo:live-demos}}
See look and feel


\section{Micropython}
\label{\detokenize{get-started/micropython::doc}}\label{\detokenize{get-started/micropython:micropython}}
play with it in micropython


\section{Simulator on PC}
\label{\detokenize{get-started/pc-simulator::doc}}\label{\detokenize{get-started/pc-simulator:simulator-on-pc}}
You can try out the LittlevGL \sphinxstylestrong{using only your PC} without any development boards. Write a code, run it on the PC and see the result on the monitor. It is cross-platform: Windows, Linux and OSX are supported.The written code is portable, you can simply copy it when using an embedded hardware.

The simulator is also very useful to report bugs because it means common platform for every user. So it’s a good idea the reproduce a bug in simualtor and use the code snippen in the \sphinxhref{https://forum.littelvgl.com}{Forum}.


\subsection{Select an IDE}
\label{\detokenize{get-started/pc-simulator:select-an-ide}}
The simulator is ported to valrious IDEs. Choose your favourite IDE, read its README on GitHub, download the project, and load it to the IDE.



In followings the set-up guide of Eclipse CDT is described in more details.


\subsection{Set-up Eclipse CDT}
\label{\detokenize{get-started/pc-simulator:set-up-eclipse-cdt}}

\subsubsection{Install Eclipse CDT}
\label{\detokenize{get-started/pc-simulator:install-eclipse-cdt}}
Eclipse CDT is C/C++ IDE. You can use other IDEs as well but in this tutorial the configuration for Eclipse CDT is shown.

Eclipse is a Java based software therefore be sure \sphinxstylestrong{Java Runtime Environment} is installed on your system.

On Debian-based distros (e.g. Ubuntu): \sphinxcode{sudo apt-get install default-jre}

You can download Eclipse’s CDT from: \sphinxhref{http://www.eclipse.org/downloads/}{https://eclipse.org/cdt/}. Start the installer and choose \sphinxstyleemphasis{Eclipse CDT} from the list.


\subsubsection{Install SDL 2}
\label{\detokenize{get-started/pc-simulator:install-sdl-2}}
The PC simulator uses the \sphinxhref{https://www.libsdl.org/download-2.0.php}{SDL 2} cross platform library to simulate a TFT display and a touch pad.


\paragraph{Linux}
\label{\detokenize{get-started/pc-simulator:linux}}
On \sphinxstylestrong{Linux} you can easily install SDL2 using a terminal:
\begin{enumerate}
\item {} 
Find the current version of SDL2: \sphinxcode{apt-cache search libsdl2 (e.g. libsdl2-2.0-0)}

\item {} 
Install SDL2: \sphinxcode{sudo apt-get install libsdl2-2.0-0} (replace with the found version)

\item {} 
Install SDL2 development package: \sphinxcode{sudo apt-get install libsdl2-dev}

\item {} 
If build essentials are not installed yet: \sphinxcode{sudo apt-get install build-essential}

\end{enumerate}


\paragraph{Windows}
\label{\detokenize{get-started/pc-simulator:windows}}
If you are using \sphinxstylestrong{Windows} firstly you need to install MinGW (\sphinxhref{http://mingw-w64.org/doku.php/download}{64 bit version}). After it do the following steps to add SDL2:
\begin{enumerate}
\item {} 
Download the development libraries of SDL.Go to \sphinxurl{https://www.libsdl.org/download-2.0.php} and download \sphinxstyleemphasis{Development Libraries: SDL2-devel-2.0.5-mingw.tar.gz}

\item {} 
Uncompress the file and go to \sphinxstyleemphasis{x86\_64-w64-mingw32} directory (for 64 bit MinGW) or to \sphinxstyleemphasis{i686-w64-mingw32} (for 32 bit MinGW)

\item {} 
Copy \_…\sphinxstyleemphasis{mingw32/include/SDL2} folder to \sphinxstyleemphasis{C:/MinGW/…/x86\_64-w64-mingw32/include}

\item {} 
Copy \_…\sphinxstyleemphasis{mingw32/lib/} content to \sphinxstyleemphasis{C:/MinGW/…/x86\_64-w64-mingw32/lib}

\item {} 
Copy \_…\sphinxstyleemphasis{mingw32/bin/SDL2.dll} to \sphinxstyleemphasis{\{eclipse\_worksapce\}/pc\_simulator/Debug/}.  Do it later when Eclipse is installed.

\end{enumerate}

Note: If you will use \sphinxstylestrong{Microsoft Visual Studio} instead of Eclipse then you don’t have to install MinGW.


\paragraph{OSX}
\label{\detokenize{get-started/pc-simulator:osx}}
On \sphinxstylestrong{OSX} you can easily install SDL2 with brew: \sphinxcode{brew install sdl2}

If something is not working I suggest \sphinxhref{http://lazyfoo.net/tutorials/SDL/01\_hello\_SDL/index.php}{this tutorial} to get started with SDL.


\subsubsection{Pre-configured project}
\label{\detokenize{get-started/pc-simulator:pre-configured-project}}
A pre-configured graphics library project (based on the latest release) is always available.
You can find it on \sphinxhref{https://github.com/littlevgl/proj\_pc}{GitHub} or on the \sphinxhref{https://littlevgl.com/download}{Download} page.
(The project is configured for Eclipse CDT.)


\subsubsection{Add the pre-configured project to Eclipse CDT}
\label{\detokenize{get-started/pc-simulator:add-the-pre-configured-project-to-eclipse-cdt}}
Run Eclipse CDT. It will show a dialogue about the \sphinxstylestrong{workspace path}. Before accepting it check that path and copy (and unzip) the downloaded pre-configured project there. Now you can accept the workspace path. Of course you can modify this path but in that case copy the project to that location.

Close the start up window and go to \sphinxstylestrong{File-\textgreater{}Import} and choose \sphinxstylestrong{General-\textgreater{}Existing project into Workspace}. \sphinxstylestrong{Browse the root directory} of the project and click \sphinxstylestrong{Finish}

On \sphinxstylestrong{Windows} you have to do two additional things:
\begin{itemize}
\item {} 
Copy the \sphinxstylestrong{SDL2.dll} into the project’s Debug folder

\item {} 
Righ click on the project -\textgreater{} Project properties -\textgreater{} C/C++ Build -\textgreater{} Settings -\textgreater{} Libraries -\textgreater{} Add … and add \sphinxstyleemphasis{mingw32} above SDLmain and SDL. (The order is important: mingw32, SDLmain, SDL)

\end{itemize}


\subsubsection{Compile and Run}
\label{\detokenize{get-started/pc-simulator:compile-and-run}}
Now you are ready to run the Littlev Graphics Library on your PC. Click on the Hammer Icon on the top menu bar to Build the project. If you have done everything right you will not get any errors. Note that on some systems additional steps might be required to “see” SDL 2 from Eclipse but in most of cases the configurtions in the downloaded project is enough.

After a success build click on the Play button on the top menu bar to run the project. Now a window should appear in the middle of your screen.

Now everything is ready to use the Littlev Graphics Library in the practice or begin the development on your PC.


\chapter{Porting}
\label{\detokenize{porting/index::doc}}\label{\detokenize{porting/index:porting}}

\section{System overview}
\label{\detokenize{porting/sys::doc}}\label{\detokenize{porting/sys:system-overview}}
\sphinxincludegraphics{{sys}.png}System architecture of Littlev Graphics Library

\sphinxstylestrong{Application}
Your application which creates the GUI and handles the specific tasks.

\sphinxstylestrong{LittlevGL}
The graphics library itself. Your application can communicate with the library to create a GUI. It contains a HAL (Hardware Abstraction Layer) interface to register your display and input device drivers.

\sphinxstylestrong{Driver}
Besides your specific drivers, it contains functions to drive your display, optionally to a GPU and to read the touchpad or buttons.


\bigskip\hrule\bigskip


There are \sphinxstylestrong{two typical hardware set-ups} depending on the MCU has an LCD/TFT driver periphery or not. In both cases, a frame buffer will be required to store the current image of the screen.
\begin{enumerate}
\item {} 
\sphinxstylestrong{MCU with TFT/LCD driver}
If your MCU has a TFT/LCD driver periphery then you can connect a display directly via RGB interface.
In this case, the frame buffer can be in the internal RAM (if the MCU has enough RAM) or in the external RAM (if the MCU has a memory interface).

\item {} 
\sphinxstylestrong{External display controller}
If the MCU doesn’t have TFT/LCD driver interface then an external display controller (E.g. SSD1963, SSD1306, ILI9341) has to be used.
In this case, the MCU can communicate with the display controller via Parallel port, SPI or sometimes I2C.
The frame buffer is usually located in the display controller which saves a lot of RAM for the MCU.

\end{enumerate}


\section{Set-up a project}
\label{\detokenize{porting/project::doc}}\label{\detokenize{porting/project:set-up-a-project}}

\subsection{Get the library}
\label{\detokenize{porting/project:get-the-library}}
The Littlev Graphics Library is available on GitHub: \sphinxurl{https://github.com/littlevgl/lvgl}.
You can clone or download the latest version of the library from here or you can use the \sphinxhref{https://littlevgl.com/download}{Download} page as well.

The graphics library is the \sphinxstylestrong{lvgl} directory which should be copied into your project.


\subsection{Config file}
\label{\detokenize{porting/project:config-file}}
There is a configuration header file for LittlevGL called \sphinxstylestrong{lv\_conf.h}. It sets the library’s basic behavior, disable unused modules and features, adjust the size of memory buffers in compile time.

Copy \sphinxstylestrong{lvgl/lv\_conf\_template.h} next to the \sphinxstyleemphasis{lvgl} directory and rename it to \sphinxstyleemphasis{lv\_conf.h}. Open the file and change the \sphinxcode{\#if 0} at the beginning to \sphinxcode{\#if 1} to enable its content.

In the config file comments explain the meaning of the options. Check at least these three config options and modify them according to your hardware:
\begin{enumerate}
\item {} 
\sphinxstylestrong{LV\_HOR\_RES\_MAX} Your display’s horizontal resolution

\item {} 
\sphinxstylestrong{LV\_VER\_RES\_MAX} Your display’s vertical resolution

\item {} 
\sphinxstylestrong{LV\_COLOR\_DEPTH} 8 for (RG332), 16 for (RGB565) or 32 for (RGB888 and ARGB8888).

\end{enumerate}


\subsection{Initialization}
\label{\detokenize{porting/project:initialization}}
In order to use the graphics library you have to initialize it and the other components too. To order of the initialization is:
\begin{enumerate}
\item {} 
Call \sphinxstyleemphasis{lv\_init()}

\item {} 
Initialize your drivers

\item {} 
Register the display and input devices drivers in LittlevGL. (see below)

\item {} 
Call \sphinxcode{lv\_tick\_inc(x)} in every \sphinxcode{x} milliseconds in an interrupt to tell the elapsed time. (see below)

\item {} 
Call \sphinxcode{lv\_task\_handler()} periodically in every few milliseconds to handle LittlevGL realted tasks. (see below)

\end{enumerate}


\section{Display interface}
\label{\detokenize{porting/display::doc}}\label{\detokenize{porting/display:display-interface}}
To set up a display an \sphinxstylestrong{lv\_disp\_buf\_t} and an \sphinxstylestrong{lv\_disp\_drv\_t} variable has to be initialized.
\begin{itemize}
\item {} 
\sphinxstyleemphasis{lv\_disp\_buf\_t} contains internal graphics buffer(s).

\item {} 
\sphinxstyleemphasis{lv\_disp\_drv\_t} contains callback functions to iteract with your display and manipulate drawing related things.

\end{itemize}


\subsection{Display buffer}
\label{\detokenize{porting/display:display-buffer}}
\sphinxstyleemphasis{lv\_disp\_buf\_t} can bin initalized like this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{c+cm}{/*A static or global variable to store the buffers*/}
    \PYG{k}{static} \PYG{n}{lv\PYGZus{}disp\PYGZus{}buf\PYGZus{}t} \PYG{n}{disp\PYGZus{}buf}\PYG{p}{;}                    
    
    \PYG{c+cm}{/*Static or global buffer(s). The second buffer is optional*/}    
    \PYG{k}{static} \PYG{n}{lv\PYGZus{}color\PYGZus{}t} \PYG{n}{buf\PYGZus{}1}\PYG{p}{[}\PYG{n}{MY\PYGZus{}DISP\PYGZus{}HOR\PYGZus{}RES} \PYG{o}{*} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{static} \PYG{n}{lv\PYGZus{}color\PYGZus{}t} \PYG{n}{buf\PYGZus{}2}\PYG{p}{[}\PYG{n}{MY\PYGZus{}DISP\PYGZus{}HOR\PYGZus{}RES} \PYG{o}{*} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;}
    
    \PYG{c+cm}{/*Initalize {}`disp\PYGZus{}buf{}` with the buffer(s) */}
    \PYG{n}{lv\PYGZus{}disp\PYGZus{}buf\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{disp\PYGZus{}buf}\PYG{p}{,} \PYG{n}{buf\PYGZus{}1}\PYG{p}{,} \PYG{n}{buf\PYGZus{}2}\PYG{p}{,} \PYG{n}{MY\PYGZus{}DISP\PYGZus{}HOR\PYGZus{}RES}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

There are there possible configurations regarding to the buffer size:
\begin{enumerate}
\item {} 
\sphinxstylestrong{Only one buffer} this buffer will be used the render the conent of the display. Should enough to hold at least 10 lines.
LittlevGL will redraw the screen in chucks whcih fit into the buffer. However if only a smaller area is needs to be redrawn (like buttn when pressed) only the that small area will be redrawn.
It can be screen-sized as well.

\item {} 
\sphinxstylestrong{Two non screen-sized buffers} having two buffer LittlevGL can draw into one buffer while the content of the other buffer is sent to display in the background.
DMA or other hardware should be used to transfer the data to the display to let the CPU draw meanwhile.
This way the rendering and refreshing of the display become parallel. Similarly to the \sphinxstyleemphasis{Only one buffer} LittelvGL will drawn the display’s content in chunks which size is at most the size of the buffer.

\item {} 
\sphinxstylestrong{Two screen-sized buffers}
In contast to \sphinxstyleemphasis{Two non screen-sized buffers} LittelvGL will always provide the whole screen’s content not only chunks. This way the driver can simply change the address of the frame buffer to the buffer received from LittlevGL.
Therefore this method works the best when the MCU has an LCD/TFT inteface and the frambuffer is just a loaction in the RAM.

\end{enumerate}


\subsection{Display driver}
\label{\detokenize{porting/display:display-driver}}
Once the buffer iitialization is ready the display drivers needs to initalized. In the most simple case only the following two fields of \sphinxstyleemphasis{lv\_disp\_drv\_t} needs to be set:
\begin{itemize}
\item {} 
\sphinxstylestrong{buffer} pointer to an initialized \sphinxcode{lv\_disp\_buf\_t} variable.

\item {} 
\sphinxstylestrong{flush\_cb} a callback function to copy a buffer’s content to a specific area of the display.

\end{itemize}

And there are some optinal data fields:
\begin{itemize}
\item {} 
\sphinxstylestrong{hor\_res} horizontal resolution of teh display. (\sphinxstyleemphasis{LV\_HOR\_RES\_MAX} by default)

\item {} 
\sphinxstylestrong{ver\_res} vertical resolution of teh display. (\sphinxstyleemphasis{LV\_VER\_RES\_MAX} by default)

\item {} 
\sphinxstylestrong{color\_chroma\_key} a color which will be drawn as transparent on CHhrome keyed images. \sphinxstyleemphasis{LV\_COLOR\_TRANSP} by deafult (lv\_conf.h)

\item {} 
\sphinxstylestrong{user\_data} custom user data for the driver. Its type acn be modified in lv\_conf.h. (Optional)

\item {} 
\sphinxstylestrong{antialiasing} use anti-aliasing (edge smoothing). \sphinxstyleemphasis{LV\_ANTIALIAS} by deafult (lv\_conf.h)

\item {} 
\sphinxstylestrong{rotated} if \sphinxcode{1} swap \sphinxstyleemphasis{hor\_res} and \sphinxstyleemphasis{ver\_res}. LittelvGL draws in tha same direction in both case (in lines from top to buttom) so the driver also need to be reconfigured to change the display’s fill direction.

\end{itemize}

To use a GPU the following callbacks can be used:
\begin{itemize}
\item {} 
\sphinxstylestrong{mem\_fill\_cb} fill an area with a colors.

\item {} 
\sphinxstylestrong{mem\_blend\_cb} blend two buffers using opacity.

\end{itemize}

Some other optional callbacks to make easier and more optimal to work with monochrome, grayscale or other less standard dislays:
\begin{itemize}
\item {} 
\sphinxstylestrong{rounder\_cb} round the coordinates of areas to redraw. E.g. a 2x2 px can be converted to 2x8.
It can be used if the display controller can refresh only areas with specific height or width (usually 8 px height with monochrome displays).

\item {} 
\sphinxstylestrong{set\_px\_cb} a custom function to write the \sphinxstyleemphasis{buffer}.
It can be used to store the pixels in more compact way if the display has a special color format. (e.g. 1 bit monochrome, 2  bit grayscale etc.)
The buffers used in \sphinxcode{lv\_disp\_buf\_t} can be smaller to hold only the required number of bits for the given area size.

\item {} 
\sphinxstylestrong{monitor\_cb} a callback function tell how many pixels were refreshed in how much time.

\end{itemize}

To set the fields of \sphinxstyleemphasis{lv\_disp\_drv\_t} variable it needs to be intialized with \sphinxcode{lv\_disp\_drv\_init(\&disp\_drv)}.
And finally to register a display for LittlevGL the \sphinxcode{lv\_disp\_drv\_register(\&disp\_drv)} needs to be used.

All togother it looks like this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
    \PYG{n}{lv\PYGZus{}disp\PYGZus{}drv\PYGZus{}t} \PYG{n}{disp\PYGZus{}drv}\PYG{p}{;}                 \PYG{c+cm}{/*A variable to hold the drivers. Can be local varaible*/}
    \PYG{n}{lv\PYGZus{}disp\PYGZus{}drv\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{disp\PYGZus{}drv}\PYG{p}{)}\PYG{p}{;}            \PYG{c+cm}{/*Basic initialization*/}
    \PYG{n}{disp\PYGZus{}drv}\PYG{p}{.}\PYG{n}{buffer} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{disp\PYGZus{}buf}\PYG{p}{;}            \PYG{c+cm}{/*Set an initialized buffer*/}
    \PYG{n}{disp\PYGZus{}drv}\PYG{p}{.}\PYG{n}{flush\PYGZus{}cb} \PYG{o}{=} \PYG{n}{my\PYGZus{}flush\PYGZus{}cb}\PYG{p}{;}        \PYG{c+cm}{/*Set a flush callback to draw to the display*/}
    \PYG{n}{lv\PYGZus{}disp\PYGZus{}t} \PYG{o}{*} \PYG{n}{disp}\PYG{p}{;}
    \PYG{n}{disp} \PYG{o}{=} \PYG{n}{lv\PYGZus{}disp\PYGZus{}drv\PYGZus{}register}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{disp\PYGZus{}drv}\PYG{p}{)}\PYG{p}{;} \PYG{c+cm}{/*Register the direver and save the created display objects*/}
\end{sphinxVerbatim}

Here some simple examples of the callbacks:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{my\PYGZus{}flush\PYGZus{}cb}\PYG{p}{(}\PYG{n}{lv\PYGZus{}disp\PYGZus{}drv\PYGZus{}t} \PYG{o}{*} \PYG{n}{disp\PYGZus{}drv}\PYG{p}{,} \PYG{k}{const} \PYG{n}{lv\PYGZus{}area\PYGZus{}t} \PYG{o}{*} \PYG{n}{area}\PYG{p}{,} \PYG{n}{lv\PYGZus{}color\PYGZus{}t} \PYG{o}{*} \PYG{n}{color\PYGZus{}p}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/*The most simple case (but also the slowest) to put all pixels to the screen one\PYGZhy{}by\PYGZhy{}one*/}
    \PYG{k+kt}{int32\PYGZus{}t} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{n}{y} \PYG{o}{=} \PYG{n}{area}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{y1}\PYG{p}{;} \PYG{n}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{area}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{y2}\PYG{p}{;} \PYG{n}{y}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{n}{x} \PYG{o}{=} \PYG{n}{area}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{x1}\PYG{p}{;} \PYG{n}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{area}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{x2}\PYG{p}{;} \PYG{n}{x}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{put\PYGZus{}px}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{o}{*}\PYG{n}{color\PYGZus{}p}\PYG{p}{)}
            \PYG{n}{color\PYGZus{}p}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/* IMPORTANT!!!}
\PYG{c+cm}{     * Inform the graphics library that you are ready with the flushing*/}
    \PYG{n}{lv\PYGZus{}disp\PYGZus{}flush\PYGZus{}ready}\PYG{p}{(}\PYG{n}{disp}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{my\PYGZus{}mem\PYGZus{}fill\PYGZus{}cb}\PYG{p}{(}\PYG{n}{lv\PYGZus{}disp\PYGZus{}drv\PYGZus{}t} \PYG{o}{*} \PYG{n}{disp\PYGZus{}drv}\PYG{p}{,} \PYG{n}{lv\PYGZus{}color\PYGZus{}t} \PYG{o}{*} \PYG{n}{dest\PYGZus{}buf}\PYG{p}{,} \PYG{k}{const} \PYG{n}{lv\PYGZus{}area\PYGZus{}t} \PYG{o}{*} \PYG{n}{dest\PYGZus{}area}\PYG{p}{,} \PYG{k}{const} \PYG{n}{lv\PYGZus{}area\PYGZus{}t} \PYG{o}{*} \PYG{n}{fill\PYGZus{}area}\PYG{p}{,} \PYG{n}{lv\PYGZus{}color\PYGZus{}t} \PYG{n}{color}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/*It\PYGZsq{}s an example code which should be done by your GPU*/}
    \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{length}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{dest}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{color}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{my\PYGZus{}mem\PYGZus{}blend\PYGZus{}cb}\PYG{p}{(}\PYG{n}{lv\PYGZus{}disp\PYGZus{}drv\PYGZus{}t} \PYG{o}{*} \PYG{n}{disp\PYGZus{}drv}\PYG{p}{,} \PYG{n}{lv\PYGZus{}color\PYGZus{}t} \PYG{o}{*} \PYG{n}{dest}\PYG{p}{,} \PYG{k}{const} \PYG{n}{lv\PYGZus{}color\PYGZus{}t} \PYG{o}{*} \PYG{n}{src}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{length}\PYG{p}{,} \PYG{n}{lv\PYGZus{}opa\PYGZus{}t} \PYG{n}{opa}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/*It\PYGZsq{}s an example code which should be done by your GPU*/}
    \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{i}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{length}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{dest}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{lv\PYGZus{}color\PYGZus{}mix}\PYG{p}{(}\PYG{n}{dest}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{src}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{opa}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{my\PYGZus{}rounder\PYGZus{}cb}\PYG{p}{(}\PYG{n}{lv\PYGZus{}disp\PYGZus{}drv\PYGZus{}t} \PYG{o}{*} \PYG{n}{disp\PYGZus{}drv}\PYG{p}{,} \PYG{n}{lv\PYGZus{}area\PYGZus{}t} \PYG{o}{*} \PYG{n}{area}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{c+cm}{/* Update the areas as needed. Can be only larger.}
\PYG{c+cm}{   * For example to always have lines 8 px hegiht:*/}
   \PYG{n}{area}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{y1} \PYG{o}{=} \PYG{n}{area}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{y1} \PYG{o}{\PYGZam{}} \PYG{l+m+mh}{0x07}\PYG{p}{;}
   \PYG{n}{area}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{y2} \PYG{o}{=} \PYG{p}{(}\PYG{n}{area}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{y2} \PYG{o}{\PYGZam{}} \PYG{l+m+mh}{0x07}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{8}\PYG{p}{;} 
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{my\PYGZus{}set\PYGZus{}px\PYGZus{}cb}\PYG{p}{(}\PYG{n}{lv\PYGZus{}disp\PYGZus{}drv\PYGZus{}t} \PYG{o}{*} \PYG{n}{disp\PYGZus{}drv}\PYG{p}{,} \PYG{k+kt}{uint8\PYGZus{}t} \PYG{o}{*} \PYG{n}{buf}\PYG{p}{,} \PYG{n}{lv\PYGZus{}coord\PYGZus{}t} \PYG{n}{buf\PYGZus{}w}\PYG{p}{,} \PYG{n}{lv\PYGZus{}coord\PYGZus{}t} \PYG{n}{x}\PYG{p}{,} \PYG{n}{lv\PYGZus{}coord\PYGZus{}t} \PYG{n}{y}\PYG{p}{,} \PYG{n}{lv\PYGZus{}color\PYGZus{}t} \PYG{n}{color}\PYG{p}{,} \PYG{n}{lv\PYGZus{}opa\PYGZus{}t} \PYG{n}{opa}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/* Write to the buffer as required for the display. }
\PYG{c+cm}{     * Write only 1 bit for monochrome displays mapped vertically:*/}
	  \PYG{n}{buf} \PYG{o}{+}\PYG{o}{=} \PYG{n}{buf\PYGZus{}w} \PYG{o}{*} \PYG{p}{(}\PYG{n}{y} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{x}\PYG{p}{;}
	  \PYG{k}{if}\PYG{p}{(}\PYG{n}{lv\PYGZus{}color\PYGZus{}brightness}\PYG{p}{(}\PYG{n}{color}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{128}\PYG{p}{)} \PYG{p}{(}\PYG{o}{*}\PYG{n}{buf}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{y} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
	  \PYG{k}{else} \PYG{p}{(}\PYG{o}{*}\PYG{n}{buf}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{=} \PYG{o}{\PYGZti{}}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{y} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{my\PYGZus{}monitor\PYGZus{}cb}\PYG{p}{(}\PYG{n}{lv\PYGZus{}disp\PYGZus{}drv\PYGZus{}t} \PYG{o}{*} \PYG{n}{disp\PYGZus{}drv}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{time}\PYG{p}{,} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{px}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}d px refreshed in \PYGZpc{}d ms}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{time}\PYG{p}{,} \PYG{n}{ms}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Multi-display support}
\label{\detokenize{porting/display:multi-display-support}}
In LittlevGL multiple displays can be used. Just initlaizes multiple drivers and buffer and register them. Each display have its own screens and objects on the screens.
To get curently active scrren of a dsplay use \sphinxcode{lv\_disp\_get\_scr\_act(disp)} (where \sphinxcode{disp} is the return value of \sphinxcode{lv\_disp\_drv\_register}).  To set a new screen as active on a display use \sphinxcode{lv\_disp\_set\_scr\_act(screen1)}.

Or in a shorter form set a default display with \sphinxcode{lv\_disp\_set\_default(disp)} and get/set the active screen with \sphinxcode{lv\_scr\_act()} and \sphinxcode{lv\_scr\_load()}.

Learn morea bout screens in the \sphinxhref{/\#Objects}{Objects} section.


\section{Input device interface}
\label{\detokenize{porting/indev::doc}}\label{\detokenize{porting/indev:input-device-interface}}
To set up an input device an \sphinxstylestrong{lv\_indev\_drv\_t} variable has to be initialized:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lv\PYGZus{}indev\PYGZus{}drv\PYGZus{}t} \PYG{n}{indev\PYGZus{}drv}\PYG{p}{;}\PYG{n}{lv\PYGZus{}indev\PYGZus{}drv\PYGZus{}init}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{indev\PYGZus{}drv}\PYG{p}{)}\PYG{p}{;}  \PYG{c+cm}{/*Basic initialization*/}
\PYG{n}{indev\PYGZus{}drv}\PYG{p}{.}\PYG{n}{type} \PYG{o}{=}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{c+cm}{/*See below.*/}
\PYG{n}{indev\PYGZus{}drv}\PYG{p}{.}\PYG{n}{read} \PYG{o}{=}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{c+cm}{/*See below.*/}
\PYG{n}{lv\PYGZus{}indev\PYGZus{}drv\PYGZus{}register}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{indev\PYGZus{}drv}\PYG{p}{)}\PYG{p}{;}  \PYG{c+cm}{/*Register the driver in LittlevGL*/}
\end{sphinxVerbatim}

\sphinxstylestrong{type} can be
\begin{itemize}
\item {} 
LV\_INDEV\_TYPE\_POINTER: touchpad or mouse

\item {} 
LV\_INDEV\_TYPE\_KEYPAD: keyboard

\item {} 
LV\_INDEV\_TYPE\_ENCODER: left, right, push

\item {} 
LV\_INDEV\_TYPE\_BUTTON: external buttons pressing the screen

\end{itemize}

\sphinxstylestrong{read} is a function pointer which will be called periodically to report the current state of an input device. It can also buffer data and return \sphinxstyleemphasis{false} when no more data to be read or \sphinxstyleemphasis{true} when the buffer is not empty.


\subsection{Touchpad, mouse or any pointer}
\label{\detokenize{porting/indev:touchpad-mouse-or-any-pointer}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{indev\PYGZus{}drv}\PYG{p}{.}\PYG{n}{type} \PYG{o}{=} \PYG{n}{LV\PYGZus{}INDEV\PYGZus{}TYPE\PYGZus{}POINTER}\PYG{p}{;}
\PYG{n}{indev\PYGZus{}drv}\PYG{p}{.}\PYG{n}{read} \PYG{o}{=} \PYG{n}{my\PYGZus{}input\PYGZus{}read}\PYG{p}{;}
\end{sphinxVerbatim}

The read function should look like this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{bool} \PYG{n+nf}{my\PYGZus{}input\PYGZus{}read}\PYG{p}{(}\PYG{n}{lv\PYGZus{}indev\PYGZus{}data\PYGZus{}t}\PYG{o}{*}\PYG{n}{data}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{point}\PYG{p}{.}\PYG{n}{x} \PYG{o}{=} \PYG{n}{touchpad\PYGZus{}x}\PYG{p}{;}   
    \PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{point}\PYG{p}{.}\PYG{n}{y} \PYG{o}{=} \PYG{n}{touchpad\PYGZus{}y}\PYG{p}{;}
    \PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{state} \PYG{o}{=} \PYG{n}{LV\PYGZus{}INDEV\PYGZus{}STATE\PYGZus{}PR} \PYG{n}{or} \PYG{n}{LV\PYGZus{}INDEV\PYGZus{}STATE\PYGZus{}REL}\PYG{p}{;}
    \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;} \PYG{c+cm}{/*No buffering so no more data read*/}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{quote}

\sphinxstylestrong{IMPORTANT NOTE:} Touchpad drivers must return the last X/Y coordinates even when the state is \sphinxcode{LV\_INDEV\_STATE\_REL}.
\end{quote}


\subsection{Keypad or keyboard}
\label{\detokenize{porting/indev:keypad-or-keyboard}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{indev\PYGZus{}drv}\PYG{p}{.}\PYG{n}{type} \PYG{o}{=} \PYG{n}{LV\PYGZus{}INDEV\PYGZus{}TYPE\PYGZus{}KEYPAD}\PYG{p}{;}
\PYG{n}{indev\PYGZus{}drv}\PYG{p}{.}\PYG{n}{read} \PYG{o}{=} \PYG{n}{my\PYGZus{}input\PYGZus{}read}\PYG{p}{;}
\end{sphinxVerbatim}

The read function should look like this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{bool} \PYG{n+nf}{keyboard\PYGZus{}read}\PYG{p}{(}\PYG{n}{lv\PYGZus{}indev\PYGZus{}data\PYGZus{}t}\PYG{o}{*}\PYG{n}{data}\PYG{p}{)}\PYG{p}{\PYGZob{}}
  \PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{key} \PYG{o}{=} \PYG{n}{last\PYGZus{}key}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}            \PYG{c+cm}{/*Set the last pressed or released key*/}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{key\PYGZus{}pressed}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{state} \PYG{o}{=} \PYG{n}{LV\PYGZus{}INDEV\PYGZus{}STATE\PYGZus{}PR}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{else}\PYG{p}{\PYGZob{}}
    \PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{state} \PYG{o}{=} \PYG{n}{LV\PYGZus{}INDEV\PYGZus{}STATE\PYGZus{}REL}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;} \PYG{c+cm}{/*No buffering so no more data read*/}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

To use a keyboard:
\begin{itemize}
\item {} 
Register a \sphinxstyleemphasis{read} function (like above) with \sphinxstyleemphasis{LV\_INDEV\_TYPE\_KEYPAD} type.

\item {} 
\sphinxstyleemphasis{USE\_LV\_GROUP} has to be enabled in \sphinxstyleemphasis{lv\_conf.h}

\item {} 
An object group has to be created: \sphinxstyleemphasis{lv\_group\_create()} and objects have to be added: \sphinxstyleemphasis{lv\_group\_add\_obj()}

\item {} 
The created group has to be assigned to an input device: \sphinxstyleemphasis{lv\_indev\_set\_group(my\_indev, group1);}

\item {} 
Use \sphinxstyleemphasis{LV\_GROUP\_KEY}…\_ to navigate among the objects in the group

\end{itemize}

Visit \sphinxhref{Input-devices}{Touchpad-less navigation} to learn more.


\subsection{Encoder}
\label{\detokenize{porting/indev:encoder}}
With an encoder you can do 4 things:
\begin{enumerate}
\item {} 
press its button

\item {} 
long press its button

\item {} 
turn left

\item {} 
turn right

\end{enumerate}

By turning the encoder you can focus on the next/previous object. When you press the encoder on a simple object (like a button), it will be clicked. If you press the encoder on a complex object (like a list, message box etc.) the object will go to edit mode where by turning the encoder you can navigate inside the object. To leave edit mode press long the button.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{indev\PYGZus{}drv}\PYG{p}{.}\PYG{n}{type} \PYG{o}{=} \PYG{n}{LV\PYGZus{}INDEV\PYGZus{}TYPE\PYGZus{}ENCODER}\PYG{p}{;}
\PYG{n}{indev\PYGZus{}drv}\PYG{p}{.}\PYG{n}{read} \PYG{o}{=} \PYG{n}{my\PYGZus{}input\PYGZus{}read}\PYG{p}{;}
\end{sphinxVerbatim}

The read function should look like this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{bool} \PYG{n+nf}{encoder\PYGZus{}read}\PYG{p}{(}\PYG{n}{lv\PYGZus{}indev\PYGZus{}data\PYGZus{}t}\PYG{o}{*}\PYG{n}{data}\PYG{p}{)}\PYG{p}{\PYGZob{}}
  \PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{enc\PYGZus{}diff} \PYG{o}{=} \PYG{n}{enc\PYGZus{}get\PYGZus{}new\PYGZus{}moves}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{enc\PYGZus{}pressed}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{state} \PYG{o}{=} \PYG{n}{LV\PYGZus{}INDEV\PYGZus{}STATE\PYGZus{}PR}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
  \PYG{k}{else}\PYG{p}{\PYGZob{}}
    \PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{state} \PYG{o}{=} \PYG{n}{LV\PYGZus{}INDEV\PYGZus{}STATE\PYGZus{}REL}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;} \PYG{c+cm}{/*No buffering so no more data read*/}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
To use an \sphinxcode{ENCODER}, similarly to the \sphinxcode{KEYPAD}, the objects should be added to groups

\end{itemize}


\subsection{Button}
\label{\detokenize{porting/indev:button}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{indev\PYGZus{}drv}\PYG{p}{.}\PYG{n}{type} \PYG{o}{=} \PYG{n}{LV\PYGZus{}INDEV\PYGZus{}TYPE\PYGZus{}BUTTON}\PYG{p}{;}
\PYG{n}{indev\PYGZus{}drv}\PYG{p}{.}\PYG{n}{read} \PYG{o}{=} \PYG{n}{my\PYGZus{}input\PYGZus{}read}\PYG{p}{;}
\end{sphinxVerbatim}

The read function should look like this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{bool} \PYG{n+nf}{button\PYGZus{}read}\PYG{p}{(}\PYG{n}{lv\PYGZus{}indev\PYGZus{}data\PYGZus{}t}\PYG{o}{*}\PYG{n}{data}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{static} \PYG{k+kt}{uint32\PYGZus{}t} \PYG{n}{last\PYGZus{}btn} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}   \PYG{c+cm}{/*Store the last pressed button*/} 
    \PYG{k+kt}{int} \PYG{n}{btn\PYGZus{}pr} \PYG{o}{=} \PYG{n}{my\PYGZus{}btn\PYGZus{}read}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}     \PYG{c+cm}{/*Get the ID (0,1,2...) of the pressed button*/}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{btn\PYGZus{}pr} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}               \PYG{c+cm}{/*Is there a button press?*/}  
       \PYG{n}{last\PYGZus{}btn} \PYG{o}{=} \PYG{n}{btn\PYGZus{}pr}\PYG{p}{;}           \PYG{c+cm}{/*Save the ID of the pressed button*/}
       \PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{state} \PYG{o}{=} \PYG{n}{LV\PYGZus{}INDEV\PYGZus{}STATE\PYGZus{}PR}\PYG{p}{;}  \PYG{c+cm}{/*Set the pressed state*/}
    \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
       \PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{state} \PYG{o}{=} \PYG{n}{LV\PYGZus{}INDEV\PYGZus{}STATE\PYGZus{}REL}\PYG{p}{;} \PYG{c+cm}{/*Set the released state*/}
    \PYG{p}{\PYGZcb{}}
  
    \PYG{n}{data}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{btn} \PYG{o}{=} \PYG{n}{last\PYGZus{}btn}\PYG{p}{;}            \PYG{c+cm}{/*Set the last button*/}         
   
    \PYG{k}{return} \PYG{n+nb}{false}\PYG{p}{;}                    \PYG{c+cm}{/*No buffering so no more data read*/}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
The buttons need to be assigned to pixels on the screen using \sphinxcode{lv\_indev\_set\_button\_points(indev, points\_array)}. Where \sphinxstyleemphasis{points\_array} look like \sphinxcode{const lv\_point\_t points\_array{[}{]} =  \{ \{12,30\},\{60,90\}, ...\}}

\end{itemize}


\section{Tick interface}
\label{\detokenize{porting/tick::doc}}\label{\detokenize{porting/tick:tick-interface}}
The LittlevGL uses a system tick. Call the \sphinxcode{lv\_tick\_inc(tick\_period)} function periodically and tell the call period in milliseconds. For example if called in every milliseconds: \sphinxcode{lv\_tick\_inc(1)}.
It is required for LittlevGL to know the elapsed time. Therefore \sphinxcode{lv\_tick\_inc} should be called in a higher priority then \sphinxcode{lv\_task\_handler()}, for example in an interrupt.


\section{Task handler}
\label{\detokenize{porting/task-handler::doc}}\label{\detokenize{porting/task-handler:task-handler}}
To handle the tasks of LittlevGL you need to call \sphinxcode{lv\_task\_handler()} periodically in one of the followings:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{while(1)} of \sphinxstyleemphasis{main()} function

\item {} 
timer interrupt periodically (low priority then \sphinxcode{lv\_tick\_inc()})

\item {} 
an OS task periodically

\end{itemize}

The timing is not critical but it should be about 5 milliseconds to keep the system responsive.

Example:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{while}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{n}{lv\PYGZus{}task\PYGZus{}handler}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{my\PYGZus{}delay\PYGZus{}ms}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Sleep management}
\label{\detokenize{porting/sleep::doc}}\label{\detokenize{porting/sleep:sleep-management}}
The MCU can go to \sphinxstylestrong{sleep} when no user input happens. In this case the main \sphinxcode{while(1)} should look like this:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{while}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{c+cm}{/*Normal operation in \PYGZlt{} 1 sec inactivity*/} 
  \PYG{k}{if}\PYG{p}{(}\PYG{n}{lv\PYGZus{}disp\PYGZus{}get\PYGZus{}inactive\PYGZus{}time}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1000}\PYG{p}{)} \PYG{p}{\PYGZob{}}    
	  \PYG{n}{lv\PYGZus{}task\PYGZus{}handler}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}} 
  \PYG{c+cm}{/*Sleep after 1 sec inactivity*/}
  \PYG{k}{else} \PYG{p}{\PYGZob{}}                                         
	  \PYG{n}{timer\PYGZus{}stop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}   \PYG{c+cm}{/*Stop the timer where lv\PYGZus{}tick\PYGZus{}inc() is called*/}
	  \PYG{n}{sleep}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}		    \PYG{c+cm}{/*Sleep the MCU*/}
  \PYG{p}{\PYGZcb{}}
  \PYG{n}{my\PYGZus{}delay\PYGZus{}ms}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

You should also add these lines to your input device read function if a press happens:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lv\PYGZus{}tick\PYGZus{}inc}\PYG{p}{(}\PYG{n}{LV\PYGZus{}REFR\PYGZus{}PERIOD}\PYG{p}{)}\PYG{p}{;}  \PYG{c+cm}{/*Force task execution on wake\PYGZhy{}up*/}
\PYG{n}{timer\PYGZus{}start}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}                \PYG{c+cm}{/*Restart the timer where lv\PYGZus{}tick\PYGZus{}inc() is called*/}
\PYG{n}{lv\PYGZus{}task\PYGZus{}handler}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}            \PYG{c+cm}{/*Call {}`lv\PYGZus{}task\PYGZus{}handler(){}` manually to process the press event*/}
\end{sphinxVerbatim}

In addition to \sphinxcode{lv\_disp\_get\_inactive\_time()} you can check \sphinxcode{lv\_anim\_count\_running()} to see if every animations are finished.


\section{Using with an operating system}
\label{\detokenize{porting/os::doc}}\label{\detokenize{porting/os:using-with-an-operating-system}}
LittlevGL is \sphinxstylestrong{not thread-safe} by deafult. Despite it, it’s quite simple to use LittlevGL inside an operating system.

The \sphinxstylestrong{simple scenario} is to don’t use the operating system’s tasks but use \sphinxcode{lv\_task}s. An \sphinxstyleemphasis{lv\_task} is a function called periodically in \sphinxcode{lv\_task\_handler}.
In the \sphinxstyleemphasis{lv\_task} you can get the state of the sensors, buffers etc and call LittlevGL functions to refresh the GUI.
To create an \sphinxstyleemphasis{lv\_task} use: \sphinxcode{lv\_task\_create(my\_func, period\_ms, LV\_TASK\_PRIO\_LOWEST/LOW/MID/HIGH/HIGHEST, custom\_ptr)}

If you need to \sphinxstylestrong{use other task or threads} you need one mutex which should be taken before calling \sphinxcode{lv\_task\_handler} and released after it.
In addition, you have to use to that mutex in other tasks and threads around every LittlevGL (\sphinxcode{lv\_...}) related code.
This way you can use LittlevGL in a real multitasking environment. Just use a mutex to avoid concurrent calling of LittlevGL functions.



\renewcommand{\indexname}{Index}
\printindex
\end{document}