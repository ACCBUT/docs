# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, LVGL LLC
# This file is distributed under the same license as the LVGL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LVGL v7.0.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-06-17 11:01+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../overview/animation.md:5
msgid "Animations"
msgstr ""

#: ../overview/animation.md:7
msgid "You can automatically change the value of a variable between a start and an end value using animations. The animation will happen by the periodical call of an \"animator\" function with the corresponding value parameter."
msgstr ""

#: ../overview/animation.md:10
msgid "The animator functions has the following prototype:"
msgstr ""

#: ../overview/animation.md:14
msgid "This prototype is compatible with the majority of the set function of LVGL. For example lv_obj_set_x(obj, value) or lv_obj_set_width(obj, value)"
msgstr ""

#: ../overview/animation.md:16
msgid "Create an animation"
msgstr ""

#: ../overview/animation.md:17
msgid "To create an animation an lv_anim_t variable has to be initialized and configured with lv_anim_set_...() functions."
msgstr ""

#: ../overview/animation.md:74
msgid "You can apply multiple different animations on the same variable at the same time. For example, animate the x and y coordinates with lv_obj_set_x and lv_obj_set_y. However, only one animation can exist with a given variable and function pair. Therefore lv_anim_start() will delete the already existing variable-function animations."
msgstr ""

#: ../overview/animation.md:78
msgid "Animation path"
msgstr ""

#: ../overview/animation.md:80
msgid "You can determinate the path of animation. In the most simple case, it is linear, which means the current value between start and end  is changed linearly. A path is mainly a function which calculates the next value to set based on the current state of the animation. Currently, there are the following built-in paths functions:"
msgstr ""

#: ../overview/animation.md:83
msgid "lv_anim_path_linear linear animation"
msgstr ""

#: ../overview/animation.md:84
msgid "lv_anim_path_step change in one step at the end"
msgstr ""

#: ../overview/animation.md:85
msgid "lv_anim_path_ease_in slow at the beginning"
msgstr ""

#: ../overview/animation.md:86
msgid "lv_anim_path_ease_out slow at the end"
msgstr ""

#: ../overview/animation.md:87
msgid "lv_anim_path_ease_in_out slow at the beginning and end too"
msgstr ""

#: ../overview/animation.md:88
msgid "lv_anim_path_overshoot overshoot the end value"
msgstr ""

#: ../overview/animation.md:89
msgid "lv_anim_path_bounce bounce back a little from the end value (like hitting a wall)"
msgstr ""

#: ../overview/animation.md:91
msgid "A path can be initialized like this:"
msgstr ""

#: ../overview/animation.md:102
msgid "Speed vs time"
msgstr ""

#: ../overview/animation.md:103
msgid "By default, you can set the animation time. But, in some cases, the animation speed is more practical."
msgstr ""

#: ../overview/animation.md:105
msgid "The lv_anim_speed_to_time(speed, start, end) function calculates the required time in milliseconds to reach the end value from a start value with the given speed. The speed is interpreted in unit/sec dimension. For example,  lv_anim_speed_to_time(20,0,100) will give 5000 milliseconds. For example, in case of lv_obj_set_x unit is pixels so 20 means 20 px/sec speed."
msgstr ""

#: ../overview/animation.md:108
msgid "Delete animations"
msgstr ""

#: ../overview/animation.md:110
msgid "You can delete an animation by lv_anim_del(var, func) by providing the animated variable and its animator function."
msgstr ""

#: ../overview/animation.md:112
#: ../overview/display.md:174
#: ../overview/file-system.md:107
#: ../overview/image.md:312
#: ../overview/indev.md:92
#: ../overview/task.md:90
msgid "API"
msgstr ""

#: ../overview/animation.md:114
#: ../overview/indev.md:94
msgid "Input device"
msgstr ""

#: ../overview/animation.md:0
#: ../overview/display.md:0
#: ../overview/file-system.md:0
#: ../overview/image.md:0
#: ../overview/indev.md:0
#: ../overview/task.md:0
msgid "Typedefs"
msgstr ""

#: ../overview/animation.md:0
#: ../overview/display.md:0
#: ../overview/file-system.md:0
#: ../overview/image.md:0
#: ../overview/indev.md:0
#: ../overview/task.md:0
msgid "Enums"
msgstr ""

#: ../overview/animation.md:0
#: ../overview/display.md:0
#: ../overview/display.md:0
#: ../overview/file-system.md:0
#: ../overview/image.md:0
#: ../overview/image.md:0
#: ../overview/indev.md:0
#: ../overview/indev.md:0
#: ../overview/task.md:0
msgid "Functions"
msgstr ""

#: ../overview/animation.md:0
#: ../overview/image.md:14
msgid "Variables"
msgstr ""

#: ../overview/animation.md:0
#: ../overview/animation.md:0
#: ../overview/display.md:0
#: ../overview/display.md:0
#: ../overview/display.md:0
#: ../overview/display.md:0
#: ../overview/display.md:0
#: ../overview/file-system.md:0
#: ../overview/file-system.md:0
#: ../overview/file-system.md:0
#: ../overview/image.md:0
#: ../overview/image.md:0
#: ../overview/image.md:0
#: ../overview/indev.md:0
#: ../overview/task.md:0
msgid "Public Members"
msgstr ""

#: ../overview/display.md:5
msgid "Displays"
msgstr ""

#: ../None:1
msgid "The basic concept of *display* in LVGL is explained in the [Porting](/porting/display) section. So before reading further, please read the [Porting](/porting/display) section first."
msgstr ""

#: ../overview/display.md:9
msgid "In LVGL, you can have multiple displays, each with their own driver and objects."
msgstr ""

#: ../overview/display.md:11
msgid "Creating more displays is easy: just initialize more display buffers and register another driver for every display. When you create the UI, use lv_disp_set_default(disp) to tell the library which display to create objects on."
msgstr ""

#: ../overview/display.md:14
msgid "Why would you want multi-display support? Here are some examples:"
msgstr ""

#: ../overview/display.md:15
msgid "Have a \"normal\" TFT display with local UI and create \"virtual\" screens on VNC on demand. (You need to add your VNC driver)."
msgstr ""

#: ../overview/display.md:16
msgid "Have a large TFT display and a small monochrome display."
msgstr ""

#: ../overview/display.md:17
msgid "Have some smaller and simple displays in a large instrument or technology."
msgstr ""

#: ../overview/display.md:18
msgid "Have two large TFT displays: one for a customer and one for the shop assistant."
msgstr ""

#: ../overview/display.md:20
msgid "Using only one display"
msgstr ""

#: ../overview/display.md:21
msgid "Using more displays can be useful, but in most cases, it's not required. Therefore, the whole concept of multi-display is completely hidden if you register only one display. By default, the lastly created (the only one) display is used as default."
msgstr ""

#: ../overview/display.md:24
msgid "lv_scr_act(), lv_scr_load(scr), lv_layer_top(), lv_layer_sys(), LV_HOR_RES and LV_VER_RES are always applied on the lastly created (default) screen. If you pass NULL as disp parameter to display related function, usually the default display will be used. E.g. lv_disp_trig_activity(NULL) will trigger a user activity on the default screen. (See below in Inactivity)."
msgstr ""

#: ../overview/display.md:28
msgid "Mirror display"
msgstr ""

#: ../overview/display.md:30
msgid "To mirror the image of the display to another display, you don't need to use the multi-display support. Just transfer the buffer received in drv.flush_cb to another display too."
msgstr ""

#: ../overview/display.md:32
msgid "Split image"
msgstr ""

#: ../overview/display.md:33
msgid "You can create a larger display from smaller ones. You can create it as below:"
msgstr ""

#: ../overview/display.md:34
msgid "Set the resolution of the displays to the large display's resolution."
msgstr ""

#: ../overview/display.md:35
msgid "In drv.flush_cb, truncate and modify the area parameter for each display."
msgstr ""

#: ../overview/display.md:36
msgid "Send the buffer's content to each display with the truncated area."
msgstr ""

#: ../overview/display.md:38
msgid "Screens"
msgstr ""

#: ../overview/display.md:40
msgid "Every display has each set of Screens and the object on the screens."
msgstr ""

#: ../overview/display.md:42
msgid "Be sure not to confuse displays and screens:"
msgstr ""

#: ../overview/display.md:44
msgid "Displays are the physical hardware drawing the pixels."
msgstr ""

#: ../overview/display.md:45
msgid "Screens are the high-level root objects associated with a particular display. One display can have multiple screens associated with it, but not vice versa."
msgstr ""

#: ../overview/display.md:47
msgid "Screens can be considered the highest level containers which have no parent. The screen's size is always equal to its display and size their position is (0;0). Therefore, the screens coordinates can't be changed, i.e. lv_obj_set_pos(), lv_obj_set_size() or similar functions can't be used on screens."
msgstr ""

#: ../overview/display.md:50
msgid "A screen can be created from any object type but, the two most typical types are the Base object and the Image (to create a wallpaper)."
msgstr ""

#: ../overview/display.md:52
msgid "To create a screen, use lv_obj_t * scr = lv_<type>_create(NULL, copy). copy can be an other screen to copy it."
msgstr ""

#: ../overview/display.md:54
msgid "To load a screen, use lv_scr_load(scr). To get the active screen, use lv_scr_act(). These functions works on the default display. If you want to to specify which display to work on, use lv_disp_get_scr_act(disp) and lv_disp_load_scr(disp, scr)."
msgstr ""

#: ../overview/display.md:56
msgid "Screens can be deleted with lv_obj_del(scr), but ensure that you do not delete the currently loaded screen."
msgstr ""

#: ../overview/display.md:58
msgid "Opaque screen"
msgstr ""

#: ../overview/display.md:59
msgid "Usually, the opacity of the screen is LV_OPA_COVER to provide a solid background for its children."
msgstr ""

#: ../overview/display.md:61
msgid "However, in some special cases, you might want a transparent screen. For example, if you have a video player that renders video frames on a lower layer, you want to create an OSD menu on the upper layer (over the video) using LVGL."
msgstr ""

#: ../overview/display.md:63
msgid "To do this, the screen should have a style that sets body.opa or image.opa to LV_OPA_TRANSP (or another non-opaque value) to make the screen opaque."
msgstr ""

#: ../overview/display.md:65
msgid "Also, LV_COLOR_SCREEN_TRANSP needs to be enabled. Please note that it only works with LV_COLOR_DEPTH = 32."
msgstr ""

#: ../overview/display.md:67
msgid "The Alpha channel of 32-bit colors will be 0 where there are no objects and will be 255 where there are solid objects."
msgstr ""

#: ../overview/display.md:69
msgid "Features of displays"
msgstr ""

#: ../overview/display.md:71
msgid "Inactivity"
msgstr ""

#: ../overview/display.md:73
msgid "The user's inactivity is measured on each display. Every use of an Input device (if associated with the display) counts as an activity. To get time elapsed since the last activity, use lv_disp_get_inactive_time(disp). If NULL is passed, the overall smallest inactivity time will be returned from all displays (not the default display)."
msgstr ""

#: ../overview/display.md:76
msgid "You can manually trigger an activity using lv_disp_trig_activity(disp). If disp is NULL, the default screen will be used (and not all displays)."
msgstr ""

#: ../overview/display.md:78
#: ../overview/display.md:185
msgid "Colors"
msgstr ""

#: ../overview/display.md:80
msgid "The color module handles all color-related functions like changing color depth, creating colors from hex code, converting between color depths, mixing colors, etc."
msgstr ""

#: ../overview/display.md:82
msgid "The following variable types are defined by the color module:"
msgstr ""

#: ../overview/display.md:84
msgid "lv_color1_t Store monochrome color. For compatibility, it also has R, G, B fields but they are always the same value (1 byte)"
msgstr ""

#: ../overview/display.md:85
msgid "lv_color8_t A structure to store R (3 bit),G (3 bit),B (2 bit) components for 8-bit colors (1 byte)"
msgstr ""

#: ../overview/display.md:86
msgid "lv_color16_t A structure to store R (5 bit),G (6 bit),B (5 bit) components for 16-bit colors (2 byte)"
msgstr ""

#: ../overview/display.md:87
msgid "lv_color32_t A structure to store R (8 bit),G (8 bit), B (8 bit) components for 24-bit colors (4 byte)"
msgstr ""

#: ../overview/display.md:88
msgid "lv_color_t Equal to lv_color1/8/16/24_t according to color depth settings"
msgstr ""

#: ../overview/display.md:89
msgid "lv_color_int_t uint8_t, uint16_t or uint32_t according to color depth setting. Used to build color arrays from plain numbers."
msgstr ""

#: ../overview/display.md:90
msgid "lv_opa_t A simple uint8_t type to describe opacity."
msgstr ""

#: ../overview/display.md:92
msgid "The lv_color_t, lv_color1_t, lv_color8_t, lv_color16_t and lv_color32_t types have got four fields:"
msgstr ""

#: ../overview/display.md:94
msgid "ch.red red channel"
msgstr ""

#: ../overview/display.md:95
msgid "ch.green green channel"
msgstr ""

#: ../overview/display.md:96
msgid "ch.blue blue channel"
msgstr ""

#: ../overview/display.md:97
msgid "full red + green + blue as one number"
msgstr ""

#: ../overview/display.md:99
msgid "You can set the current color depth in lv_conf.h, by setting the LV_COLOR_DEPTH define to 1 (monochrome), 8, 16 or 32."
msgstr ""

#: ../overview/display.md:101
msgid "Convert color"
msgstr ""

#: ../overview/display.md:102
msgid "You can convert a color from the current color depth to another. The converter functions return with a number, so you have to use the full field:"
msgstr ""

#: ../overview/display.md:123
msgid "Swap 16 colors"
msgstr ""

#: ../overview/display.md:124
msgid "You may set LV_COLOR_16_SWAP in lv_conf.h to swap the bytes of RGB565 colors. It's useful if you send the 16-bit colors via a byte-oriented interface like SPI."
msgstr ""

#: ../overview/display.md:126
msgid "As 16-bit numbers are stored in Little Endian format (lower byte on the lower address), the interface will send the lower byte first. However, displays usually need the higher byte first. A mismatch in the byte order will result in highly distorted colors."
msgstr ""

#: ../overview/display.md:128
msgid "Create and mix colors"
msgstr ""

#: ../overview/display.md:129
msgid "You can create colors with the current color depth using the LV_COLOR_MAKE macro. It takes 3 arguments (red, green, blue) as 8-bit numbers. For example to create light red color: my_color = COLOR_MAKE(0xFF,0x80,0x80)."
msgstr ""

#: ../overview/display.md:132
msgid "Colors can be created from HEX codes too: my_color = lv_color_hex(0x288ACF) or my_color = lv_folro_hex3(0x28C)."
msgstr ""

#: ../overview/display.md:134
msgid "Mixing two colors is possible with mixed_color = lv_color_mix(color1, color2, ratio). Ration can be 0..255. 0 results fully color2, 255 result fully color1."
msgstr ""

#: ../overview/display.md:136
msgid "Colors can be created with from HSV space too using lv_color_hsv_to_rgb(hue, saturation, value) . hue should be in 0..360 range, saturation and value in 0..100 range."
msgstr ""

#: ../overview/display.md:138
msgid "Opacity"
msgstr ""

#: ../overview/display.md:139
msgid "To describe opacity the lv_opa_t type is created as a wrapper to uint8_t. Some defines are also introduced:"
msgstr ""

#: ../overview/display.md:141
msgid "LV_OPA_TRANSP Value: 0, means the opacity makes the color completely transparent"
msgstr ""

#: ../overview/display.md:142
msgid "LV_OPA_10 Value: 25, means the color covers only a little"
msgstr ""

#: ../overview/display.md:143
msgid "LV_OPA_20 ... OPA_80 come logically"
msgstr ""

#: ../overview/display.md:144
msgid "LV_OPA_90 Value: 229, means the color near completely covers"
msgstr ""

#: ../overview/display.md:145
msgid "LV_OPA_COVER Value: 255, means the color completely covers"
msgstr ""

#: ../overview/display.md:147
msgid "You can also use the LV_OPA_* defines in lv_color_mix() as a ratio."
msgstr ""

#: ../overview/display.md:149
msgid "Built-in colors"
msgstr ""

#: ../overview/display.md:151
msgid "The color module defines the most basic colors such as:"
msgstr ""

#: ../overview/display.md:153
msgid "LV_COLOR_WHITE"
msgstr ""

#: ../overview/display.md:154
msgid "LV_COLOR_BLACK"
msgstr ""

#: ../overview/display.md:155
msgid "LV_COLOR_GRAY"
msgstr ""

#: ../overview/display.md:156
msgid "LV_COLOR_SILVER"
msgstr ""

#: ../overview/display.md:157
msgid "LV_COLOR_RED"
msgstr ""

#: ../overview/display.md:158
msgid "LV_COLOR_MAROON"
msgstr ""

#: ../overview/display.md:159
msgid "LV_COLOR_LIME"
msgstr ""

#: ../overview/display.md:160
msgid "LV_COLOR_GREEN"
msgstr ""

#: ../overview/display.md:161
msgid "LV_COLOR_OLIVE"
msgstr ""

#: ../overview/display.md:162
msgid "LV_COLOR_BLUE"
msgstr ""

#: ../overview/display.md:163
msgid "LV_COLOR_NAVY"
msgstr ""

#: ../overview/display.md:164
msgid "LV_COLOR_TEAL"
msgstr ""

#: ../overview/display.md:165
msgid "LV_COLOR_CYAN"
msgstr ""

#: ../overview/display.md:166
msgid "LV_COLOR_AQUA"
msgstr ""

#: ../overview/display.md:167
msgid "LV_COLOR_PURPLE"
msgstr ""

#: ../overview/display.md:168
msgid "LV_COLOR_MAGENTA"
msgstr ""

#: ../overview/display.md:169
msgid "LV_COLOR_ORANGE"
msgstr ""

#: ../overview/display.md:170
msgid "LV_COLOR_YELLOW"
msgstr ""

#: ../overview/display.md:172
msgid "as well as LV_COLOR_WHITE (fully white)."
msgstr ""

#: ../overview/display.md:176
msgid "Display"
msgstr ""

#: ../overview/drawing.md:5
msgid "Drawing"
msgstr ""

#: ../overview/drawing.md:7
msgid "With LVGL, you don't need to draw anything manually. Just create objects (like buttons and labels), move and change them and LVGL will refresh and redraw what is required."
msgstr ""

#: ../overview/drawing.md:9
msgid "However, it might be useful to have a basic understanding of how drawing happens in LVGL."
msgstr ""

#: ../overview/drawing.md:11
msgid "The basic concept is to not draw directly to the screen, but draw to an internal buffer first and then copy that buffer to screen when the rendering is ready. It has two main advantages:"
msgstr ""

#: ../overview/drawing.md:12
msgid "Avoids flickering while layers of the UI are drawn. For example, when drawing a background + button + text, each \"stage\" would be visible for a short time."
msgstr ""

#: ../overview/drawing.md:13
msgid "It's faster to modify a buffer in RAM and finally write one pixel once than read/write a display directly on each pixel access. (e.g. via a display controller with SPI interface). Hence, it's suitable for pixels that are redrawn multiple times (e.g. background + button + text)."
msgstr ""

#: ../overview/drawing.md:16
msgid "Buffering types"
msgstr ""

#: ../overview/drawing.md:18
msgid "As you already might learn in the Porting section, there are 3 types of buffers:"
msgstr ""

#: ../overview/drawing.md:19
msgid "One buffer -  LVGL draws the content of the screen into a buffer and sends it to the display. The buffer can be smaller than the screen. In this case, the larger areas will be redrawn in multiple parts. If only small areas changes (e.g. button press), then only those areas will be refreshed."
msgstr ""

#: ../overview/drawing.md:20
msgid "Two non-screen-sized buffers -  having two buffers, LVGL can draw into one buffer while the content of the other buffer is sent to display in the background. DMA or other hardware should be used to transfer the data to the display to let the CPU draw meanwhile. This way, the rendering and refreshing of the display become parallel. If the buffer is smaller than the area to refresh, LVGL will draw the display's content in chunks similar to the One buffer."
msgstr ""

#: ../overview/drawing.md:23
msgid "Two screen-sized buffers - In contrast to Two non-screen-sized buffers, LVGL will always provide the whole screen's content, not only chunks. This way, the driver can simply change the address of the frame buffer to the buffer received from LVGL. Therefore, this method works best when the MCU has an LCD/TFT interface and the frame buffer is just a location in the RAM."
msgstr ""

#: ../overview/drawing.md:27
msgid "Mechanism of screen refreshing"
msgstr ""

#: ../overview/drawing.md:29
msgid "Something happens on the GUI which requires redrawing. For example, a button has been pressed, a chart has been changed or an animation happened, etc."
msgstr ""

#: ../overview/drawing.md:30
msgid "LVGL saves the changed object's old and new area into a buffer, called an Invalid area buffer. For optimization, in some cases, objects are not added to the buffer:"
msgstr ""

#: ../overview/drawing.md:31
msgid "Hidden objects are not added."
msgstr ""

#: ../overview/drawing.md:32
msgid "Objects completely out of their parent are not added."
msgstr ""

#: ../overview/drawing.md:33
msgid "Areas out of the parent are cropped to the parent's area."
msgstr ""

#: ../overview/drawing.md:34
msgid "The object on other screens are not added."
msgstr ""

#: ../overview/drawing.md:35
msgid "In every LV_DISP_DEF_REFR_PERIOD (set in lv_conf.h):"
msgstr ""

#: ../overview/drawing.md:36
msgid "LVGL checks the invalid areas and joins the adjacent or intersecting areas."
msgstr ""

#: ../overview/drawing.md:37
msgid "Takes the first joined area, if it's smaller than the display buffer, then simply draw the areas' content to the display buffer. If the area doesn't fit into the buffer, draw as many lines as possible to the display buffer."
msgstr ""

#: ../overview/drawing.md:38
msgid "When the area is drawn, call flush_cb from the display driver to refresh the display."
msgstr ""

#: ../overview/drawing.md:39
msgid "If the area was larger than the buffer, redraw the remaining parts too."
msgstr ""

#: ../overview/drawing.md:40
msgid "Do the same with all the joined areas."
msgstr ""

#: ../overview/drawing.md:42
msgid "While an area is redrawn, the library searches the most top object which covers the area to redraw, and starts to draw from that object. For example, if a button's label has changed, the library will see that it's enough to draw the button under the text, and it's not required to draw the background too."
msgstr ""

#: ../overview/drawing.md:45
msgid "The difference between buffer types regarding the drawing mechanism is the following:"
msgstr ""

#: ../overview/drawing.md:46
msgid "One buffer - LVGL needs to wait for lv_disp_flush_ready() (called at the end of flush_cb) before starting to redraw the next part."
msgstr ""

#: ../overview/drawing.md:47
msgid "Two non-screen-sized buffers -  LVGL can immediately draw to the second buffer when the first is sent to flush_cb because the flushing should be done by DMA (or similar hardware) in the background."
msgstr ""

#: ../overview/drawing.md:48
msgid "Two screen-sized buffers -  After calling flush_cb, the first buffer, if being displayed as frame buffer. Its content is copied to the second buffer and all the changes are drawn on top of it."
msgstr ""

#: ../overview/drawing.md:50
msgid "Masking"
msgstr ""

#: ../overview/drawing.md:51
msgid "Masking is the basic concept of LVGL's drawing engine. To use LVGL it's not required to know about the mechanisms described here, but you might find interesting to know how the drawing works under hood."
msgstr ""

#: ../overview/drawing.md:55
msgid "To learn masking let's learn the steps of drawing first:"
msgstr ""

#: ../overview/drawing.md:56
msgid "Create a draw descriptor from an object's styles (e.g. lv_draw_rect_dsc_t). It tells the parameters of drawing, for example the colors, widths, opacity, fonts, radius, etc."
msgstr ""

#: ../overview/drawing.md:58
msgid "Call the draw function with the initialized descriptor and some other parameters. It renders the primitive shape to the current draw buffer."
msgstr ""

#: ../overview/drawing.md:60
msgid "If the shape is very simple and doesn't require masks go to #5. Else create the required masks (e.g. a rounded rectangle mask)"
msgstr ""

#: ../overview/drawing.md:62
msgid "Apply all the created mask(s) for one or a few lines. It create 0..255 values into a mask buffer with the \"shape\" of the created masks. E.g. in case of a \"line mask\" according to the parameters of the mask, keep one side of the buffer as it is (255 by default) and set the rest to 0 to indicate that the latter side should be removed."
msgstr ""

#: ../overview/drawing.md:66
msgid "Blend the image or rectangle to the screen. During blending masks (make some pixels transparent or opaque), blending modes (additive, subtractive, etc), opacity are handled."
msgstr ""

#: ../overview/drawing.md:68
msgid "Repeat from  #4."
msgstr ""

#: ../overview/drawing.md:70
msgid "Masks are used the create almost every basic primitives:"
msgstr ""

#: ../overview/drawing.md:71
msgid "letters create a mask from the letter and draw a “letter-colored” rectangle using the mask."
msgstr ""

#: ../overview/drawing.md:72
msgid "line created from 4 l\"ine masks\", to mask out the left, right, top and bottom part of the line to get perfectly perpendicular line ending"
msgstr ""

#: ../overview/drawing.md:73
msgid "rounded rectangle a mask is created real-time for each line of a rounded rectangle and a normal filled rectangle is drawn according to the mask."
msgstr ""

#: ../overview/drawing.md:74
msgid "clip corner to clip to overflowing content on the rounded corners also a rounded rectangle mask is applied."
msgstr ""

#: ../overview/drawing.md:75
msgid "rectangle border same as a rounded rectangle, but inner part is masked out too"
msgstr ""

#: ../overview/drawing.md:76
msgid "arc drawing a circle border is drawn, but an arc mask is applied."
msgstr ""

#: ../overview/drawing.md:77
msgid "ARGB images the alpha channel is separated into a mask and the image is drawn as a normal RGB image."
msgstr ""

#: ../overview/drawing.md:79
msgid "As mentioned in #3 above in some cases no mask is required:"
msgstr ""

#: ../overview/drawing.md:80
msgid "a mono colored, not rounded rectangles"
msgstr ""

#: ../overview/drawing.md:81
msgid "RGB images"
msgstr ""

#: ../overview/drawing.md:83
msgid "LVGL has the following built-in mask types which can be calculated and applied real-time:"
msgstr ""

#: ../overview/drawing.md:84
msgid "LV_DRAW_MASK_TYPE_LINE Removes a side of a line (top, bottom, left or right). lv_draw_line uses 4 of it. Essentially, every (skew) line is bounded with 4 line masks by forming a rectangle."
msgstr ""

#: ../overview/drawing.md:86
msgid "LV_DRAW_MASK_TYPE_RADIUS Removes the inner or outer parts of a rectangle which can have radius too. It's also used to create circles by setting the radius to large value (LV_RADIUS_CIRCLE)"
msgstr ""

#: ../overview/drawing.md:87
msgid "LV_DRAW_MASK_TYPE_ANGLE Removes a circle sector. It is used by lv_draw_arc to remove the \"empty\" sector."
msgstr ""

#: ../overview/drawing.md:88
msgid "LV_DRAW_MASK_TYPE_FADE Create a vertical fade (change opacity)"
msgstr ""

#: ../overview/drawing.md:89
msgid "LV_DRAW_MASK_TYPE_MAP The mask is stored in an array and the necessary parts are applied"
msgstr ""

#: ../overview/drawing.md:91
msgid "Masks are create and removed automatically during drawing but the lv_objmask allows the user to add masks. Here is an example:"
msgstr ""

#: ../lv_examples/src/lv_ex_widgets/lv_ex_objmask/index.rst:14
#: ../lv_examples/src/lv_ex_widgets/lv_ex_objmask/index.rst:30
msgid "code"
msgstr ""

#: ../lv_examples/src/lv_ex_widgets/lv_ex_objmask/index.rst:38
msgid "No examples yet."
msgstr ""

#: ../overview/event.md:5
msgid "Events"
msgstr ""

#: ../overview/event.md:7
msgid "Events are triggered in LVGL when something happens which might be interesting to the user, e.g. if an object:"
msgstr ""

#: ../overview/event.md:8
msgid "is clicked"
msgstr ""

#: ../overview/event.md:9
msgid "is dragged"
msgstr ""

#: ../overview/event.md:10
msgid "its value has changed, etc."
msgstr ""

#: ../overview/event.md:12
msgid "The user can assign a callback function to an object to see these events. In practice, it looks like this:"
msgstr ""

#: ../overview/event.md:51
msgid "More objects can use the same event callback."
msgstr ""

#: ../overview/event.md:53
msgid "Event types"
msgstr ""

#: ../overview/event.md:55
msgid "The following event types exist:"
msgstr ""

#: ../overview/event.md:57
msgid "Generic events"
msgstr ""

#: ../overview/event.md:59
msgid "All objects (such as Buttons/Labels/Sliders etc.) receive these generic events regardless of their type."
msgstr ""

#: ../overview/event.md:61
msgid "Related to the input devices"
msgstr ""

#: ../overview/event.md:62
msgid "These are sent when an object is pressed/released etc. by the user. They are used not only for Pointers but can used for Keypad, Encoder and Button input devices as well. Visit the Overview of input devices section to learn more about them."
msgstr ""

#: ../overview/event.md:63
msgid "LV_EVENT_PRESSED The object has been pressed"
msgstr ""

#: ../overview/event.md:64
msgid "LV_EVENT_PRESSING The object is being pressed (sent continuously while pressing)"
msgstr ""

#: ../overview/event.md:65
msgid "LV_EVENT_PRESS_LOST The input device is still being pressed but is no longer on the object"
msgstr ""

#: ../overview/event.md:66
msgid "LV_EVENT_SHORT_CLICKED Released before LV_INDEV_LONG_PRESS_TIME time. Not called if dragged."
msgstr ""

#: ../overview/event.md:67
msgid "LV_EVENT_LONG_PRESSED  Pressing for LV_INDEV_LONG_PRESS_TIME time.  Not called if dragged."
msgstr ""

#: ../overview/event.md:68
msgid "LV_EVENT_LONG_PRESSED_REPEAT Called after LV_INDEV_LONG_PRESS_TIME in every LV_INDEV_LONG_PRESS_REP_TIME ms.  Not called if dragged."
msgstr ""

#: ../overview/event.md:69
msgid "LV_EVENT_CLICKED Called on release if not dragged (regardless to long press)"
msgstr ""

#: ../overview/event.md:70
msgid "LV_EVENT_RELEASED  Called in every case when the object has been released even if it was dragged. Not called if slid from the object while pressing and released outside of the object. In this case, LV_EVENT_PRESS_LOST is sent."
msgstr ""

#: ../overview/event.md:72
msgid "Related to pointer"
msgstr ""

#: ../overview/event.md:73
msgid "These events are sent only by pointer-like input devices (E.g. mouse or touchpad)"
msgstr ""

#: ../overview/event.md:74
msgid "LV_EVENT_DRAG_BEGIN Dragging of the object has started"
msgstr ""

#: ../overview/event.md:75
msgid "LV_EVENT_DRAG_END Dragging finished (including drag throw)"
msgstr ""

#: ../overview/event.md:76
msgid "LV_EVENT_DRAG_THROW_BEGIN Drag throw started (released after drag with \"momentum\")"
msgstr ""

#: ../overview/event.md:78
msgid "Related to keypad and encoder"
msgstr ""

#: ../overview/event.md:79
msgid "These events are sent by keypad and encoder input devices. Learn more about Groups in [overview/indev](Input devices) section."
msgstr ""

#: ../overview/event.md:80
msgid "LV_EVENT_KEY A Key is sent to the object. Typically when it was pressed or repeated after a long press"
msgstr ""

#: ../overview/event.md:81
msgid "LV_EVENT_FOCUSED The object is focused in its group"
msgstr ""

#: ../overview/event.md:82
msgid "LV_EVENT_DEFOCUSED The object is defocused in its group"
msgstr ""

#: ../overview/event.md:84
msgid "General events"
msgstr ""

#: ../overview/event.md:85
msgid "Other general events sent by the library."
msgstr ""

#: ../overview/event.md:86
msgid "LV_EVENT_DELETE The object is being deleted. Free the related user-allocated data."
msgstr ""

#: ../overview/event.md:88
msgid "Special events"
msgstr ""

#: ../overview/event.md:89
msgid "These events are specific to a particular object type."
msgstr ""

#: ../overview/event.md:90
msgid "LV_EVENT_VALUE_CHANGED The object value has changed (e.g. for a Slider)"
msgstr ""

#: ../overview/event.md:91
msgid "LV_EVENT_INSERT Something is inserted to the object. (Typically to a Text area)"
msgstr ""

#: ../overview/event.md:92
msgid "LV_EVENT_APPLY  \"Ok\", \"Apply\" or similar specific button has clicked. (Typically from a Keyboard object)"
msgstr ""

#: ../overview/event.md:93
msgid "LV_EVENT_CANCEL \"Close\", \"Cancel\" or similar specific button has clicked. (Typically from a Keyboard object)"
msgstr ""

#: ../overview/event.md:94
msgid "LV_EVENT_REFRESH Query to refresh the object. Never sent by the library but can be sent by the user."
msgstr ""

#: ../overview/event.md:96
msgid "Visit particular Object type's documentation to understand which events are used by an object type."
msgstr ""

#: ../overview/event.md:98
msgid "Custom data"
msgstr ""

#: ../overview/event.md:99
msgid "Some events might contain custom data. For example, LV_EVENT_VALUE_CHANGED in some cases tells the new value. For more information, see the particular Object type's documentation. To get the custom data in the event callback use lv_event_get_data()."
msgstr ""

#: ../overview/event.md:102
msgid "The type of the custom data depends on the sending object but if it's a"
msgstr ""

#: ../overview/event.md:103
msgid "single number then it's uint32_t * or int32_t *"
msgstr ""

#: ../overview/event.md:104
msgid "text then char *  or const char *"
msgstr ""

#: ../overview/event.md:106
msgid "Send events manually"
msgstr ""

#: ../overview/event.md:108
msgid "To manually send events to an object, use lv_event_send(obj, LV_EVENT_..., &custom_data)."
msgstr ""

#: ../overview/event.md:110
msgid "For example, it can be used to manually close a message box by simulating a button press (although there are simpler ways of doing this):"
msgstr ""

#: ../overview/event.md:117
msgid "Or to perform refresh generically:"
msgstr ""

#: ../overview/file-system.md:5
msgid "File system"
msgstr ""

#: ../overview/file-system.md:7
msgid "LVGL has a 'File system' abstraction module that enables you to attach any type of file systems. The file system is identified by a drive letter. For example, if the SD card is associated with the letter 'S', a file can be reached like \"S:path/to/file.txt\"."
msgstr ""

#: ../overview/file-system.md:11
msgid "Add a driver"
msgstr ""

#: ../overview/file-system.md:13
msgid "To add a driver, lv_fs_drv_t needs to be initialized like this:"
msgstr ""

#: ../overview/file-system.md:44
msgid "Any of the callbacks can be NULL to indicate that that operation is not supported."
msgstr ""

#: ../overview/file-system.md:46
msgid "As an example of how the callbacks are used, if you use lv_fs_open(&file, \"S:/folder/file.txt\", LV_FS_MODE_WR), LVGL:"
msgstr ""

#: ../overview/file-system.md:48
msgid "Verifies that a registered drive exists with the letter 'S'."
msgstr ""

#: ../overview/file-system.md:49
msgid "Checks if it's open_cb is implemented (not NULL)."
msgstr ""

#: ../overview/file-system.md:50
msgid "Calls the set open_cb with \"folder/file.txt\" path."
msgstr ""

#: ../overview/file-system.md:52
msgid "Usage example"
msgstr ""

#: ../overview/file-system.md:54
msgid "The example below shows how to read from a file:"
msgstr ""

#: ../overview/file-system.md:68
msgid "The mode in lv_fs_open can be LV_FS_MODE_WR to open for write or LV_FS_MODE_RD | LV_FS_MODE_WR for both"
msgstr ""

#: ../overview/file-system.md:70
msgid "This example shows how to read a directory's content. It's up to the driver how to mark the directories, but it can be a good practice to insert a '/' in front of the directory name."
msgstr ""

#: ../overview/file-system.md:96
msgid "Use drivers for images"
msgstr ""

#: ../overview/file-system.md:98
msgid "Image objects can be opened from files too (besides variables stored in the flash)."
msgstr ""

#: ../overview/file-system.md:100
msgid "To initialize the image, the following callbacks are required:"
msgstr ""

#: ../overview/file-system.md:101
msgid "open"
msgstr ""

#: ../overview/file-system.md:102
msgid "close"
msgstr ""

#: ../overview/file-system.md:103
msgid "read"
msgstr ""

#: ../overview/file-system.md:104
msgid "seek"
msgstr ""

#: ../overview/file-system.md:105
msgid "tell"
msgstr ""

#: ../overview/font.md:5
msgid "Fonts"
msgstr ""

#: ../overview/font.md:7
msgid "In LVGL fonts are collections of bitmaps and other information required to render the images of the letters (glyph). A font is stored in a lv_font_t variable and can be set in style's text_font field. For example:"
msgstr ""

#: ../overview/font.md:13
msgid "The fonts have a bpp (bits per pixel) property. It shows how many bits are used to describe a pixel in the font. The value stored for a pixel determines the pixel's opacity. This way, with higher bpp, the edges of the letter can be smoother. The possible bpp values are 1, 2, 4 and 8 (higher value means better quality)."
msgstr ""

#: ../overview/font.md:16
msgid "The bpp also affects the required memory size to store the font. For example, bpp = 4 makes the font nearly 4 times greater compared to bpp = 1."
msgstr ""

#: ../overview/font.md:18
msgid "Unicode support"
msgstr ""

#: ../overview/font.md:20
msgid "LVGL supports UTF-8 encoded Unicode characters. Your editor needs to be configureed to save your code/text as UTF-8 (usually this the default) and be sure that, LV_TXT_ENC is set to LV_TXT_ENC_UTF8 in lv_conf.h. (This is the default value)"
msgstr ""

#: ../overview/font.md:23
msgid "To test it try"
msgstr ""

#: ../overview/font.md:29
msgid "If all works well, a ✓ character should be displayed."
msgstr ""

#: ../overview/font.md:31
msgid "Built-in fonts"
msgstr ""

#: ../overview/font.md:33
msgid "There are several built-in fonts in different sizes, which can be enabled in lv_conf.h by LV_FONT_... defines:"
msgstr ""

#: ../overview/font.md:34
msgid "LV_FONT_MONTSERRAT_12 12 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:35
msgid "LV_FONT_MONTSERRAT_14 14 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:36
msgid "LV_FONT_MONTSERRAT_16 16 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:37
msgid "LV_FONT_MONTSERRAT_18 18 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:38
msgid "LV_FONT_MONTSERRAT_20 20 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:39
msgid "LV_FONT_MONTSERRAT_22 22 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:40
msgid "LV_FONT_MONTSERRAT_24 24 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:41
msgid "LV_FONT_MONTSERRAT_26 26 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:42
msgid "LV_FONT_MONTSERRAT_28 28 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:43
msgid "LV_FONT_MONTSERRAT_30 30 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:44
msgid "LV_FONT_MONTSERRAT_32 32 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:45
msgid "LV_FONT_MONTSERRAT_34 34 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:46
msgid "LV_FONT_MONTSERRAT_36 36 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:47
msgid "LV_FONT_MONTSERRAT_38 38 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:48
msgid "LV_FONT_MONTSERRAT_40 40 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:49
msgid "LV_FONT_MONTSERRAT_42 42 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:50
msgid "LV_FONT_MONTSERRAT_44 44 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:51
msgid "LV_FONT_MONTSERRAT_46 46 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:52
msgid "LV_FONT_MONTSERRAT_48 48 px ASCII + built-in symbol"
msgstr ""

#: ../overview/font.md:54
msgid "LV_FONT_MONTSERRAT_12_SUBPX 12 px font with subpixel rendering"
msgstr ""

#: ../overview/font.md:55
msgid "LV_FONT_MONTSERRAT_28_COMPRESSED 28 px compressed font with 3 bpp"
msgstr ""

#: ../overview/font.md:56
msgid "LV_FONT_DEJAVU_16_PERSIAN_HEBREW 16 px Hebrew, Arabic, Perisan letters and all their forms"
msgstr ""

#: ../overview/font.md:57
msgid "LV_FONT_SIMSUN_16_CJK            16 px 1000 most common CJK radicals"
msgstr ""

#: ../overview/font.md:58
msgid "LV_FONT_UNSCII_8 8 px pixel perfect font"
msgstr ""

#: ../overview/font.md:60
msgid "The built-in fonts are global variables with names like lv_font_montserrat_16 for 16 px hight font. To use them in a style, just add a pointer to a font variable like shown above."
msgstr ""

#: ../overview/font.md:62
msgid "The built-in fonts have bpp = 4, contains the ASCII characters and uses the Montserrat font."
msgstr ""

#: ../overview/font.md:64
msgid "In addition to the ASCII range, the following symbols are also added to the built-in fonts from the FontAwesome font."
msgstr ""

#: ../overview/font.md:66
msgid "Built-in Symbols in LVGL"
msgstr ""

#: ../overview/font.md:68
msgid "The symbols can be used as:"
msgstr ""

#: ../overview/font.md:73
msgid "Or with together with strings:"
msgstr ""

#: ../overview/font.md:78
msgid "Or more symbols together:"
msgstr ""

#: ../overview/font.md:83
msgid "Special features"
msgstr ""

#: ../overview/font.md:85
msgid "Bidirectional support"
msgstr ""

#: ../overview/font.md:86
msgid "Most of the languages use Left-to-Right (LTR for short) writing direction, however some languages (such as Hebrew, Persian or Arabic) uses Right-to-Left (RTL for short) direction."
msgstr ""

#: ../overview/font.md:88
msgid "LVGL not only supports RTL texts but supports mixed (a.k.a. bidirectional, BiDi) text rendering too. Some examples:"
msgstr ""

#: ../overview/font.md:90
msgid "Bidirectional text examples"
msgstr ""

#: ../overview/font.md:92
msgid "The BiDi support can be enabled by LV_USE_BIDI in lv_conf.h"
msgstr ""

#: ../overview/font.md:94
msgid "All texts have a base direction (LTR or RTL) which determines some rendering rules and the default alignment of the text (Left or Right). However, in LVGL, base direction is applied not only for labels. It's a general property which can be set for every object. If unset then it will be inherited from the parent. So it's enough to set the base direction of the screen and every object will inherit it."
msgstr ""

#: ../overview/font.md:99
msgid "The default base direction of screen can be set by LV_BIDI_BASE_DIR_DEF in lv_conf.h and other objects inherit the base direction from their parent."
msgstr ""

#: ../overview/font.md:101
msgid "To set an object's base direction use lv_obj_set_base_dir(obj, base_dir).  The possible base direction are:"
msgstr ""

#: ../overview/font.md:102
msgid "LV_BIDI_DIR_LTR: Left to Right base direction"
msgstr ""

#: ../overview/font.md:103
msgid "LV_BIDI_DIR_RTL: Right to Left base direction"
msgstr ""

#: ../overview/font.md:104
msgid "LV_BIDI_DIR_AUTO: Auto detect base direction"
msgstr ""

#: ../overview/font.md:105
msgid "LV_BIDI_DIR_INHERIT: Inherit the base direction from the parent (default for non-screen objects)"
msgstr ""

#: ../overview/font.md:107
msgid "This list summarizes the effect of RTL base direction on objects:"
msgstr ""

#: ../overview/font.md:108
msgid "Create objects by default on the right"
msgstr ""

#: ../overview/font.md:109
msgid "lv_tabview: displays tabs from right to left"
msgstr ""

#: ../overview/font.md:110
msgid "lv_checkbox: Show the box on the right"
msgstr ""

#: ../overview/font.md:111
msgid "lv_btnmatrix: Show buttons from right to left"
msgstr ""

#: ../overview/font.md:112
msgid "lv_list: Show the icon on the right"
msgstr ""

#: ../overview/font.md:113
msgid "lv_dropdown: Align the options to the right"
msgstr ""

#: ../overview/font.md:114
msgid "The texts in lv_table, lv_btnmatrix, lv_keyboard, lv_tabview, lv_dropdown, lv_roller are \"BiDi processed\" to be displayed correctly"
msgstr ""

#: ../overview/font.md:116
msgid "Arabic and Persian support"
msgstr ""

#: ../overview/font.md:117
msgid "There are some special rules to display Arabic and Persian characters: the form of the character depends on their position in the text. A different form of the same letter needs to be used if it isolated, start, middle or end position. Besides these some conjunction rules also should be taken into account."
msgstr ""

#: ../overview/font.md:120
msgid "LVGL supports to apply these rules if LV_USE_ARABIC_PERSIAN_CHARS is enabled."
msgstr ""

#: ../overview/font.md:122
msgid "However, there some limitations:"
msgstr ""

#: ../overview/font.md:123
msgid "Only displaying texts is supported (e.g. on labels), text inputs (e.g. text area) doesn't support this feature"
msgstr ""

#: ../overview/font.md:124
msgid "Static text (i.e. const) are not processed. E.g. texts set by lv_label_set_text() will \"Arabic processed\" but lv_lable_set_text_static() won't."
msgstr ""

#: ../overview/font.md:125
msgid "Text get functions (e.g. lv_label_get_text()) will return the processed text."
msgstr ""

#: ../overview/font.md:127
msgid "Subpixel rendering"
msgstr ""

#: ../overview/font.md:129
msgid "Subpixel rendering means to triple the horizontal resolution by rendering on Red, Green and Blue channel instead of pixel level. It takes advantage of the position of physical color channels of each pixel. It results in higher quality letter anti-aliasing. Lear more here."
msgstr ""

#: ../overview/font.md:132
msgid "Subpixel rendering requires to generate the fonts with special settings:"
msgstr ""

#: ../overview/font.md:133
msgid "In the online converter tick the Subpixel box"
msgstr ""

#: ../overview/font.md:134
msgid "In the command line tool use --lcd flag. Note that the generated font needs about 3 times more memory."
msgstr ""

#: ../overview/font.md:136
msgid "Subpixel rendering works only if the color channels of the pixels have a horizontal layout. That is the R, G, B channels are next each other and not above each other. The order of color channels also needs to match with the library settings. By default the LVGL assumes RGB order, however it can be swapped by setting LV_SUBPX_BGR  1 in lv_conf.h."
msgstr ""

#: ../overview/font.md:139
msgid "Compress fonts"
msgstr ""

#: ../overview/font.md:140
msgid "The bitmaps of the fonts can be compressed by"
msgstr ""

#: ../overview/font.md:141
msgid "ticking the Compressed check box in the online converter"
msgstr ""

#: ../overview/font.md:142
msgid "not passing --no-compress flag to the offline converter (applies compression by default)"
msgstr ""

#: ../overview/font.md:144
msgid "The compression is more effective with larger fonts and higher bpp. However, it's about 30% slower to render the compressed fonts. Therefore it's recommended to compress only the largest fonts of user interface, because"
msgstr ""

#: ../overview/font.md:146
msgid "they need the most memory"
msgstr ""

#: ../overview/font.md:147
msgid "they can be compressed better"
msgstr ""

#: ../overview/font.md:148
msgid "and probably they are used less frequently then the medium sized fonts. (so performance cost is smaller)"
msgstr ""

#: ../overview/font.md:150
msgid "Add new font"
msgstr ""

#: ../overview/font.md:152
msgid "There are several ways to add a new font to your project:"
msgstr ""

#: ../overview/font.md:153
msgid "The simplest method is to use the Online font converter. Just set the parameters, click the Convert button, copy the font to your project and use it. Be sure to carefully read the steps provided on that site or you will get an error while converting."
msgstr ""

#: ../overview/font.md:154
msgid "Use the Offline font converter. (Requires Node.js to be installed)"
msgstr ""

#: ../overview/font.md:155
msgid "If you want to create something like the built-in fonts (Roboto font and symbols) but in different size and/or ranges, you can use the built_in_font_gen.py script in lvgl/scripts/built_in_font folder. (It requires Python and lv_font_conv to be installed)"
msgstr ""

#: ../overview/font.md:158
msgid "To declare the font in a file, use LV_FONT_DECLARE(my_font_name)."
msgstr ""

#: ../overview/font.md:160
msgid "To make the fonts globally available (like the builtin fonts), add them to LV_FONT_CUSTOM_DECLARE in lv_conf.h."
msgstr ""

#: ../overview/font.md:162
msgid "Add new symbols"
msgstr ""

#: ../overview/font.md:163
msgid "The built-in symbols are created from FontAwesome font."
msgstr ""

#: ../overview/font.md:165
msgid "Search symbol on https://fontawesome.com. For example the USB symbol. Copy it's Unicode ID which is 0xf287 in this case."
msgstr ""

#: ../overview/font.md:166
msgid "Open the Online font converter. Add Add FontAwesome.woff. ."
msgstr ""

#: ../overview/font.md:167
msgid "Set the parameters such as Name, Size, BPP. You'll use this name to declare and use the font in your code."
msgstr ""

#: ../overview/font.md:168
msgid "Add the Unicode ID of the symbol to the range field. E.g. 0xf287 for the USB symbol. More symbols can be enumerated with ,."
msgstr ""

#: ../overview/font.md:169
msgid "Convert the font and copy it to your project. Make sure to compile the .c file of your font."
msgstr ""

#: ../overview/font.md:170
msgid "Declare the font using extern lv_font_t my_font_name; or simply LV_FONT_DECLARE(my_font_name);."
msgstr ""

#: ../overview/font.md:172
msgid "Using the symbol"
msgstr ""

#: ../overview/font.md:173
msgid "Convert the Unicode value to UTF8. You can do it e.g on this site. For 0xf287 the Hex UTF-8 bytes are EF 8A 87."
msgstr ""

#: ../overview/font.md:174
msgid "Create a define from the UTF8 values: #define MY_USB_SYMBOL \"\\xEF\\x8A\\x87\""
msgstr ""

#: ../overview/font.md:175
msgid "Create a label and set the text. Eg. lv_label_set_text(label, MY_USB_SYMBOL)"
msgstr ""

#: ../overview/font.md:177
msgid "Note - lv_label_set_text(label, MY_USB_SYMBOL) searches for this symbol in the font defined in style.text.font properties. To use the symbol you may need to change it. Eg  style.text.font = my_font_name"
msgstr ""

#: ../overview/font.md:179
msgid "Add a new font engine"
msgstr ""

#: ../overview/font.md:181
msgid "LVGL's font interface is designed to be very flexible. You don't need to use LVGL's internal font engine but, you can add your own. For example, use FreeType to real-time render glyphs from TTF fonts or use an external flash to store the font's bitmap and read them when the library needs them."
msgstr ""

#: ../overview/font.md:185
msgid "A raedy to use FreeType can be found in lv_freetype repository."
msgstr ""

#: ../overview/font.md:187
msgid "To do this a custom lv_font_t variable needs to be created:"
msgstr ""

#: ../overview/image.md:5
msgid "Images"
msgstr ""

#: ../overview/image.md:7
msgid "An image can be a file or variable which stores the bitmap itself and some metadata."
msgstr ""

#: ../overview/image.md:9
msgid "Store images"
msgstr ""

#: ../overview/image.md:10
msgid "You can store images in two places"
msgstr ""

#: ../overview/image.md:11
msgid "as a variable in the internal memory (RAM or ROM)"
msgstr ""

#: ../overview/image.md:12
msgid "as a file"
msgstr ""

#: ../overview/image.md:15
msgid "The images stored internally in a variable is composed mainly of an lv_img_dsc_t structure with the following fields:"
msgstr ""

#: ../overview/image.md:16
msgid "header"
msgstr ""

#: ../overview/image.md:17
msgid "cf Color format. See below"
msgstr ""

#: ../overview/image.md:18
msgid "w width in pixels (<= 2048)"
msgstr ""

#: ../overview/image.md:19
msgid "h height in pixels (<= 2048)"
msgstr ""

#: ../overview/image.md:20
msgid "always zero 3 bits which need to be always zero"
msgstr ""

#: ../overview/image.md:21
msgid "reserved reserved for future use"
msgstr ""

#: ../overview/image.md:22
msgid "data pointer to an array where the image itself is stored"
msgstr ""

#: ../overview/image.md:23
msgid "data_size length of data in bytes"
msgstr ""

#: ../overview/image.md:25
msgid "These are usually stored within a project as C files. They are linked into the resulting executable like any other constant data."
msgstr ""

#: ../overview/image.md:27
msgid "Files"
msgstr ""

#: ../overview/image.md:28
msgid "To deal with files you need to add a Drive to LVGL. In short, a Drive is a collection of functions (open, read, close, etc.) registered in LVGL to make file operations. You can add an interface to a standard file system (FAT32 on SD card) or you create your simple file system to read data from an SPI Flash memory. In every case, a Drive is just an abstraction to read and/or write data to a memory. See the File system section to learn more."
msgstr ""

#: ../overview/image.md:33
msgid "Images stored as files are not linked into the resulting executable, and must be read to RAM before being drawn. As a result, they are not as resource-friendly as variable images. However, they are easier to replace without needing to recompile the main program."
msgstr ""

#: ../overview/image.md:35
msgid "Color formats"
msgstr ""

#: ../overview/image.md:36
msgid "Various built-in color formats are supported:"
msgstr ""

#: ../overview/image.md:37
msgid "LV_IMG_CF_TRUE_COLOR Simply stores the RGB colors (in whatever color depth LVGL is configured for)."
msgstr ""

#: ../overview/image.md:38
msgid "LV_IMG_CF_TRUE_COLOR_ALPHA Like LV_IMG_CF_TRUE_COLOR but it also adds an alpha (transparency) byte for every pixel."
msgstr ""

#: ../overview/image.md:39
msgid "LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED Like LV_IMG_CF_TRUE_COLOR but if a pixel has LV_COLOR_TRANSP (set in lv_conf.h) color the pixel will be transparent."
msgstr ""

#: ../overview/image.md:40
msgid "LV_IMG_CF_INDEXED_1/2/4/8BIT Uses a palette with 2, 4, 16 or 256 colors and stores each pixel in 1, 2, 4 or 8 bits."
msgstr ""

#: ../overview/image.md:41
msgid "LV_IMG_CF_ALPHA_1/2/4/8BIT Only stores the Alpha value on 1, 2, 4 or 8 bits. The pixels take the color of style.image.color and the set opacity. The source image has to be an alpha channel. This is ideal for bitmaps similar to fonts (where the whole image is one color but you'd like to be able to change it)."
msgstr ""

#: ../overview/image.md:43
msgid "The bytes of the LV_IMG_CF_TRUE_COLOR images are stored in the following order."
msgstr ""

#: ../overview/image.md:45
msgid "For 32-bit color depth:"
msgstr ""

#: ../overview/image.md:46
msgid "Byte 0: Blue"
msgstr ""

#: ../overview/image.md:47
msgid "Byte 1: Green"
msgstr ""

#: ../overview/image.md:48
msgid "Byte 2: Red"
msgstr ""

#: ../overview/image.md:49
msgid "Byte 3: Alpha"
msgstr ""

#: ../overview/image.md:51
msgid "For 16-bit color depth:"
msgstr ""

#: ../overview/image.md:52
msgid "Byte 0: Green 3 lower bit, Blue 5 bit"
msgstr ""

#: ../overview/image.md:53
msgid "Byte 1: Red 5 bit, Green 3 higher bit"
msgstr ""

#: ../overview/image.md:54
#: ../overview/image.md:58
msgid "Byte 2: Alpha byte (only with LV_IMG_CF_TRUE_COLOR_ALPHA)"
msgstr ""

#: ../overview/image.md:56
msgid "For 8-bit color depth:"
msgstr ""

#: ../overview/image.md:57
msgid "Byte 0: Red 3 bit, Green 3 bit, Blue 2 bit"
msgstr ""

#: ../overview/image.md:60
msgid "You can store images in a Raw format to indicate that, it's not a built-in color format and an external Image decoder needs to be used to decode the image."
msgstr ""

#: ../overview/image.md:61
msgid "LV_IMG_CF_RAW Indicates a basic raw image (e.g. a PNG or JPG image)."
msgstr ""

#: ../overview/image.md:62
msgid "LV_IMG_CF_RAW_ALPHA Indicates that the image has alpha and an alpha byte is added for every pixel."
msgstr ""

#: ../overview/image.md:63
msgid "LV_IMG_CF_RAW_CHROME_KEYED Indicates that the image is chrome keyed as described in LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED above."
msgstr ""

#: ../overview/image.md:65
msgid "Add and use images"
msgstr ""

#: ../overview/image.md:67
msgid "You can add images to LVGL in two ways:"
msgstr ""

#: ../overview/image.md:68
msgid "using the online converter"
msgstr ""

#: ../overview/image.md:69
msgid "manually create images"
msgstr ""

#: ../overview/image.md:71
msgid "Online converter"
msgstr ""

#: ../overview/image.md:72
msgid "The online Image converter is available here: https://lvgl.io/tools/imageconverter"
msgstr ""

#: ../overview/image.md:74
msgid "Adding an image to LVGL via online converter is easy."
msgstr ""

#: ../overview/image.md:76
msgid "You need to select a BMP, PNG or JPG image first."
msgstr ""

#: ../overview/image.md:77
msgid "Give the image a name that will be used within LVGL."
msgstr ""

#: ../overview/image.md:78
msgid "Select the Color format."
msgstr ""

#: ../overview/image.md:79
msgid "Select the type of image you want. Choosing a binary will generate a .bin file that must be stored separately and read using the file support. Choosing a variable will generate a standard C file that can be linked into your project."
msgstr ""

#: ../overview/image.md:80
msgid "Hit the Convert button. Once the conversion is finished, your browser will automatically download the resulting file."
msgstr ""

#: ../overview/image.md:82
msgid "In the converter C arrays (variables), the bitmaps for all the color depths (1, 8, 16 or 32) are included in the C file, but only the color depth that matches LV_COLOR_DEPTH in lv_conf.h will actually be linked into the resulting executable."
msgstr ""

#: ../overview/image.md:84
msgid "In case of binary files, you need to specify the color format you want:"
msgstr ""

#: ../overview/image.md:85
msgid "RGB332 for 8-bit color depth"
msgstr ""

#: ../overview/image.md:86
msgid "RGB565 for 16-bit color depth"
msgstr ""

#: ../overview/image.md:87
msgid "RGB565 Swap for 16-bit color depth (two bytes are swapped)"
msgstr ""

#: ../overview/image.md:88
msgid "RGB888 for 32-bit color depth"
msgstr ""

#: ../overview/image.md:90
msgid "Manually create an image"
msgstr ""

#: ../overview/image.md:91
msgid "If you are generating an image at run-time, you can craft an image variable to display it using LVGL. For example:"
msgstr ""

#: ../overview/image.md:107
msgid "If the color format is LV_IMG_CF_TRUE_COLOR_ALPHA you can set data_size like 80 * 60 * LV_IMG_PX_SIZE_ALPHA_BYTE."
msgstr ""

#: ../overview/image.md:109
msgid "Another (possibly simpler) option to create and display an image at run-time is to use the Canvas object."
msgstr ""

#: ../overview/image.md:111
msgid "Use images"
msgstr ""

#: ../overview/image.md:113
msgid "The simplest way to use an image in LVGL is to display it with an lv_img object:"
msgstr ""

#: ../overview/image.md:125
msgid "If the image was converted with the online converter, you should use LV_IMG_DECLARE(my_icon_dsc) to declare the image in the file where you want to use it."
msgstr ""

#: ../overview/image.md:127
#: ../overview/image.md:314
msgid "Image decoder"
msgstr ""

#: ../overview/image.md:128
msgid "As you can see in the Color formats section, LVGL supports several built-in image formats. In many cases, these will be all you need. LVGL doesn't directly support, however, generic image formats like PNG or JPG."
msgstr ""

#: ../overview/image.md:130
msgid "To handle non-built-in image formats, you need to use external libraries and attach them to LVGL via the Image decoder interface."
msgstr ""

#: ../overview/image.md:132
msgid "The image decoder consists of 4 callbacks:"
msgstr ""

#: ../overview/image.md:133
msgid "info get some basic info about the image (width, height and color format)."
msgstr ""

#: ../overview/image.md:134
msgid "open open the image: either store the decoded image or set it to NULL to indicate the image can be read line-by-line."
msgstr ""

#: ../overview/image.md:135
msgid "read if open didn't fully open the image this function should give some decoded data (max 1 line) from a given position."
msgstr ""

#: ../overview/image.md:136
msgid "close close the opened image, free the allocated resources."
msgstr ""

#: ../overview/image.md:138
msgid "You can add any number of image decoders. When an image needs to be drawn, the library will try all the registered image decoder until finding one which can open the image, i.e. knowing that format."
msgstr ""

#: ../overview/image.md:140
msgid "The LV_IMG_CF_TRUE_COLOR_..., LV_IMG_INDEXED_... and LV_IMG_ALPHA_... formats (essentially, all non-RAW formats) are understood by the built-in decoder."
msgstr ""

#: ../overview/image.md:142
msgid "Custom image formats"
msgstr ""

#: ../overview/image.md:144
msgid "The easiest way to create a custom image is to use the online image converter and set Raw, Raw with alpha or Raw with chrome keyed format. It will just take every byte of the binary file you uploaded and write it as the image \"bitmap\". You then need to attach an image decoder that will parse that bitmap and generate the real, renderable bitmap."
msgstr ""

#: ../overview/image.md:146
msgid "header.cf will be LV_IMG_CF_RAW, LV_IMG_CF_RAW_ALPHA or LV_IMG_CF_RAW_CHROME_KEYED accordingly. You should choose the correct format according to your needs: fully opaque image, use alpha channel or use chroma keying."
msgstr ""

#: ../overview/image.md:148
msgid "After decoding, the raw formats are considered True color by the library. In other words, the image decoder must decode the Raw images to True color according to the format described in [#color-formats](Color formats) section."
msgstr ""

#: ../overview/image.md:150
msgid "If you want to create a custom image, you should use LV_IMG_CF_USER_ENCODED_0..7 color formats. However, the library can draw the images only in True color format (or Raw but finally it's supposed to be in True color format). So the LV_IMG_CF_USER_ENCODED_... formats are not known by the library, therefore, they should be decoded to one of the known formats from [#color-formats](Color formats) section. It's possible to decode the image to a non-true color format first, for example, LV_IMG_INDEXED_4BITS, and then call the built-in decoder functions to convert it to True color."
msgstr ""

#: ../overview/image.md:154
msgid "With User encoded formats, the color format in the open function (dsc->header.cf) should be changed according to the new format."
msgstr ""

#: ../overview/image.md:156
msgid "Register an image decoder"
msgstr ""

#: ../overview/image.md:158
msgid "Here's an example of getting LVGL to work with PNG images."
msgstr ""

#: ../overview/image.md:160
msgid "First, you need to create a new image decoder and set some functions to open/close the PNG files. It should looks like this:"
msgstr ""

#: ../overview/image.md:249
msgid "So in summary:"
msgstr ""

#: ../overview/image.md:250
msgid "In decoder_info, you should collect some basic information about the image and store it in header."
msgstr ""

#: ../overview/image.md:251
msgid "In decoder_open, you should try to open the image source pointed by dsc->src. Its type is already in dsc->src_type == LV_IMG_SRC_FILE/VARIABLE. If this format/type is not supported by the decoder, return LV_RES_INV. However, if you can open the image, a pointer to the decoded True color image should be set in dsc->img_data. If the format is known but, you don't want to decode while image (e.g. no memory for it) set dsc->img_data = NULL to call read_line to get the pixels."
msgstr ""

#: ../overview/image.md:255
msgid "In decoder_close you should free all the allocated resources."
msgstr ""

#: ../overview/image.md:256
msgid "decoder_read is optional. Decoding the whole image requires extra memory and some computational overhead. However, if can decode one line of the image without decoding the whole image, you can save memory and time. To indicate that, the line read function should be used, set dsc->img_data = NULL in the open function."
msgstr ""

#: ../overview/image.md:260
msgid "Manually use an image decoder"
msgstr ""

#: ../overview/image.md:262
msgid "LVGL will use the registered image decoder automatically if you try and draw a raw image (i.e. using the lv_img object) but you can use them manually too. Create a lv_img_decoder_dsc_t variable to describe the decoding session and call lv_img_decoder_open(), lv_img_decoder_open()."
msgstr ""

#: ../overview/image.md:277
msgid "Image caching"
msgstr ""

#: ../overview/image.md:278
msgid "Sometimes it takes a lot of time to open an image. Continuously decoding a PNG image or loading images from a slow external memory would be inefficient and detrimental to the user experience."
msgstr ""

#: ../overview/image.md:281
msgid "Therefore, LVGL caches a given number of images. Caching means some images will be left open, hence LVGL can quickly access them from dsc->img_data instead of needing to decode them again."
msgstr ""

#: ../overview/image.md:283
msgid "Of course, caching images is resource-intensive as it uses more RAM (to store the decoded image). LVGL tries to optimize the process as much as possible (see below), but you will still need to evaluate if this would be beneficial for your platform or not. If you have a deeply embedded target which decodes small images from a relatively fast storage medium, image caching may not be worth it."
msgstr ""

#: ../overview/image.md:285
msgid "Cache size"
msgstr ""

#: ../overview/image.md:286
msgid "The number of cache entries can be defined in LV_IMG_CACHE_DEF_SIZE in lv_conf.h. The default value is 1 so only the most recently used image will be left open."
msgstr ""

#: ../overview/image.md:288
msgid "The size of the cache can be changed at run-time with lv_img_cache_set_size(entry_num)."
msgstr ""

#: ../overview/image.md:290
msgid "Value of images"
msgstr ""

#: ../overview/image.md:291
msgid "When you use more images than cache entries, LVGL can't cache all of the images. Instead, the library will close one of the cached images (to free space)."
msgstr ""

#: ../overview/image.md:293
msgid "To decide which image to close, LVGL uses a measurement it previously made of how long it took to open the image. Cache entries that hold slower-to-open images are considered more valuable and are kept in the cache as long as possible."
msgstr ""

#: ../overview/image.md:295
msgid "If you want or need to override LVGL's measurement, you can manually set the time to open value in the decoder open function in dsc->time_to_open = time_ms to give a higher or lower value. (Leave it unchanged to let LVGL set it.)"
msgstr ""

#: ../overview/image.md:297
msgid "Every cache entry has a \"life\" value. Every time an image opening happens through the cache, the life of all entries are decreased to make them older. When a cached image is used, its life is increased by the time to open value to make it more alive."
msgstr ""

#: ../overview/image.md:300
msgid "If there is no more space in the cache, always the entry with the smallest life will be closed."
msgstr ""

#: ../overview/image.md:302
msgid "Memory usage"
msgstr ""

#: ../overview/image.md:303
msgid "Note that, the cached image might continuously consume memory. For example, if 3 PNG images are cached, they will consume memory while they are opened."
msgstr ""

#: ../overview/image.md:305
msgid "Therefore, it's the user's responsibility to be sure there is enough RAM to cache, even the largest images at the same time."
msgstr ""

#: ../overview/image.md:307
msgid "Clean the cache"
msgstr ""

#: ../overview/image.md:308
msgid "Let's say you have loaded a PNG image into a lv_img_dsc_t my_png variable and use it in an lv_img object. If the image is already cached and you then change the underlying PNG file, you need to notify LVGL to cache the image again. Otherwise, there is no easy way of detecting that the underlying file changed and LVGL will still draw the old image."
msgstr ""

#: ../overview/image.md:310
msgid "To do this, use lv_img_cache_invalidate_src(&my_png). If NULL is passed as a parameter, the whole cache will be cleaned."
msgstr ""

#: ../overview/image.md:323
msgid "Image cache"
msgstr ""

#: ../overview/indev.md:5
msgid "Input devices"
msgstr ""

#: ../overview/indev.md:7
msgid "An input device usually means:"
msgstr ""

#: ../overview/indev.md:8
msgid "Pointer-like input device like touchpad or mouse"
msgstr ""

#: ../overview/indev.md:9
msgid "Keypads like a normal keyboard or simple numeric keypad"
msgstr ""

#: ../overview/indev.md:10
msgid "Encoders with left/right turn and push options"
msgstr ""

#: ../overview/indev.md:11
msgid "External hardware buttons which are assigned to specific points on the screen"
msgstr ""

#: ../None:1
msgid "Before reading further, please read the [Porting](/porting/indev) section of Input devices"
msgstr ""

#: ../overview/indev.md:16
msgid "Pointers"
msgstr ""

#: ../overview/indev.md:18
msgid "Pointer input devices can have a cursor. (typically for mouses)"
msgstr ""

#: ../overview/indev.md:31
msgid "Note that the cursor object should have lv_obj_set_click(cursor_obj, false). For images, clicking is disabled by default."
msgstr ""

#: ../overview/indev.md:34
msgid "Keypad and encoder"
msgstr ""

#: ../overview/indev.md:36
msgid "You can fully control the user interface without touchpad or mouse using a keypad or encoder(s). It works similar to the TAB key on the PC to select the element in an application or a web page."
msgstr ""

#: ../overview/indev.md:38
#: ../overview/indev.md:103
msgid "Groups"
msgstr ""

#: ../overview/indev.md:40
msgid "The objects, you want to control with keypad or encoder, needs to be added to a Group. In every group, there is exactly one focused object which receives the pressed keys or the encoder actions. For example, if a Text area is focused and you press some letter on a keyboard, the keys will be sent and inserted into the text area. Similarly, if a Slider is focused and you press the left or right arrows, the slider's value will be changed."
msgstr ""

#: ../overview/indev.md:45
msgid "You need to associate an input device with a group. An input device can send the keys to only one group but, a group can receive data from more than one input device too."
msgstr ""

#: ../overview/indev.md:47
msgid "To create a group use lv_group_t * g = lv_group_create() and to add an object to the group use lv_group_add_obj(g, obj)."
msgstr ""

#: ../overview/indev.md:49
msgid "The associate a group with an input device use lv_indev_set_group(indev, g), where indev is the return value of lv_indev_drv_register()"
msgstr ""

#: ../overview/indev.md:51
msgid "Keys"
msgstr ""

#: ../overview/indev.md:52
msgid "There are some predefined keys which have special meaning:"
msgstr ""

#: ../overview/indev.md:53
msgid "LV_KEY_NEXT Focus on the next object"
msgstr ""

#: ../overview/indev.md:54
msgid "LV_KEY_PREV Focus on the previous object"
msgstr ""

#: ../overview/indev.md:55
msgid "LV_KEY_ENTER Triggers LV_EVENT_PRESSED/CLICKED/LONG_PRESSED etc. events"
msgstr ""

#: ../overview/indev.md:56
msgid "LV_KEY_UP Increase value or move upwards"
msgstr ""

#: ../overview/indev.md:57
msgid "LV_KEY_DOWN Decrease value or move downwards"
msgstr ""

#: ../overview/indev.md:58
msgid "LV_KEY_RIGHT Increase value or move the the right"
msgstr ""

#: ../overview/indev.md:59
msgid "LV_KEY_LEFT Decrease value or move the the left"
msgstr ""

#: ../overview/indev.md:60
msgid "LV_KEY_ESC  Close or exit (E.g. close a Drop down list)"
msgstr ""

#: ../overview/indev.md:61
msgid "LV_KEY_DEL  Delete (E.g. a character on the right in a Text area)"
msgstr ""

#: ../overview/indev.md:62
msgid "LV_KEY_BACKSPACE Delete a character on the left (E.g. in a Text area)"
msgstr ""

#: ../overview/indev.md:63
msgid "LV_KEY_HOME Go to the beginning/top (E.g. in a Text area)"
msgstr ""

#: ../overview/indev.md:64
msgid "LV_KEY_END Go to the end (E.g. in a Text area))"
msgstr ""

#: ../overview/indev.md:66
msgid "The most important special keys are LV_KEY_NEXT/PREV, LV_KEY_ENTER and LV_KEY_UP/DOWN/LEFT/RIGHT. In your read_cb function, you should translate some of your keys to these special keys to navigate in the group and interact with the selected object."
msgstr ""

#: ../overview/indev.md:69
msgid "Usually, it's enough to use only LV_KEY_LEFT/RIGHT because most of the objects can be fully controlled with them."
msgstr ""

#: ../overview/indev.md:71
msgid "With an encoder, you should use only LV_KEY_LEFT, LV_KEY_RIGHT, and LV_KEY_ENTER."
msgstr ""

#: ../overview/indev.md:73
msgid "Edit and navigate mode"
msgstr ""

#: ../overview/indev.md:75
msgid "Since keypad has plenty of keys, it's easy to navigate between the objects and edit them using the keypad. But, the encoders have a limited number of \"keys\" hence, difficult to navigate using the default options. Navigate and Edit are created to avoid this problem with the encoders."
msgstr ""

#: ../overview/indev.md:77
msgid "In Navigate mode, the encoders LV_KEY_LEFT/RIGHT is translated to LV_KEY_NEXT/PREV. Therefore the next or previous object will be selected by turning the encoder. Pressing LV_KEY_ENTER will change to Edit mode."
msgstr ""

#: ../overview/indev.md:80
msgid "In Edit mode, LV_KEY_NEXT/PREV is usually used to edit the object. Depending on the object's type, a short or long press of LV_KEY_ENTER changes back to Navigate mode. Usually, an object which can not be pressed (like a Slider) leaves Edit mode on short click. But with object where short click has meaning (e.g. Button), long press is required."
msgstr ""

#: ../overview/indev.md:84
msgid "Styling"
msgstr ""

#: ../overview/indev.md:86
msgid "If an object is focused either by clicking it via touchpad, or focused via an encoder or keypad it goes to LV_STATE_FOCUSED. Hence focused styles will be applied on it."
msgstr ""

#: ../overview/indev.md:88
msgid "If te object goes to edit mode it goes to LV_STATE_FOCUSED | LV_STATE_EDITED state so these style properties will be shown."
msgstr ""

#: ../overview/indev.md:90
msgid "For a moew detaild description read the Style section."
msgstr ""

#: ../overview/index.md:6
msgid "Overview"
msgstr ""

#: ../overview/layer.md:6
msgid "Layers"
msgstr ""

#: ../overview/layer.md:8
msgid "Order of creation"
msgstr ""

#: ../overview/layer.md:10
msgid "By default, LVGL draws old objects on the background and new objects on the foreground."
msgstr ""

#: ../overview/layer.md:12
msgid "For example, assume we added a button to a parent object named button1 and then another button named button2. Then button1 (with its child object(s)) will be in the background and can be covered by button2 and its children."
msgstr ""

#: ../overview/layer.md:14
msgid "Creating graphical objects in Littlev Graphics Library"
msgstr ""

#: ../overview/layer.md:40
msgid "Bring to the foreground"
msgstr ""

#: ../overview/layer.md:42
msgid "There are several ways to bring an object to the foreground:"
msgstr ""

#: ../overview/layer.md:43
msgid "Use lv_obj_set_top(obj, true). If obj or any of its children is clicked, then LVGL will automatically bring the object to the foreground. It works similarly to a typical GUI on a PC. When a window in the background is clicked, it will come to the foreground automatically."
msgstr ""

#: ../overview/layer.md:45
msgid "Use lv_obj_move_foreground(obj) to explicitly tell the library to bring an object to the foreground. Similarly, use lv_obj_move_background(obj) to move to the background."
msgstr ""

#: ../overview/layer.md:46
msgid "When lv_obj_set_parent(obj, new_parent) is used, obj will be on the foreground on the new_parent."
msgstr ""

#: ../overview/layer.md:48
msgid "Top and sys layers"
msgstr ""

#: ../overview/layer.md:50
msgid "LVGL uses two special layers named as layer_top and layer_sys. Both are visible and common on all screens of a display. They are not, however, shared among multiple physical displays. The layer_top is always on top of the default screen (lv_scr_act()), and layer_sys is on top of layer_top."
msgstr ""

#: ../overview/layer.md:53
msgid "The layer_top can be used by the user to create some content visible everywhere. For example, a menu bar, a pop-up, etc. If the click attribute is enabled, then layer_top will absorb all user click and acts as a modal."
msgstr ""

#: ../overview/layer.md:58
msgid "The layer_sys is also using for similar purpose on LVGL. For example, it places the mouse cursor there to be sure it's always visible."
msgstr ""

#: ../overview/object.md:5
msgid "Objects"
msgstr ""

#: ../overview/object.md:7
msgid "In the LVGL the basic building blocks of a user interface are the objects, also called Widgets. For example a Button, Label, Image, List, Chart or Text area."
msgstr ""

#: ../overview/object.md:10
msgid "Check all the Object types here."
msgstr ""

#: ../overview/object.md:12
msgid "Object attributes"
msgstr ""

#: ../overview/object.md:14
msgid "Basic attributes"
msgstr ""

#: ../overview/object.md:16
msgid "All object types share some basic attributes:"
msgstr ""

#: ../overview/object.md:17
msgid "Position"
msgstr ""

#: ../overview/object.md:18
msgid "Size"
msgstr ""

#: ../overview/object.md:19
msgid "Parent"
msgstr ""

#: ../overview/object.md:20
msgid "Drag enable"
msgstr ""

#: ../overview/object.md:21
msgid "Click enable etc."
msgstr ""

#: ../overview/object.md:23
msgid "You can set/get these attributes with lv_obj_set_... and lv_obj_get_... functions. For example:"
msgstr ""

#: ../overview/object.md:31
msgid "To see all the available functions visit the Base object's documentation."
msgstr ""

#: ../overview/object.md:33
msgid "Specific attributes"
msgstr ""

#: ../overview/object.md:35
msgid "The object types have special attributes too. For example, a slider has"
msgstr ""

#: ../overview/object.md:36
msgid "Min. max. values"
msgstr ""

#: ../overview/object.md:37
msgid "Current value"
msgstr ""

#: ../overview/object.md:38
msgid "Custom styles"
msgstr ""

#: ../overview/object.md:40
msgid "For these attributes, every object type have unique API functions. For example for a slider:"
msgstr ""

#: ../overview/object.md:49
msgid "The API of the object types are described in their Documentation but you can also check the respective header files (e.g. lv_objx/lv_slider.h)"
msgstr ""

#: ../overview/object.md:51
msgid "Object's working mechanisms"
msgstr ""

#: ../overview/object.md:53
msgid "Parent-child structure"
msgstr ""

#: ../overview/object.md:55
msgid "A parent object can be considered as the container of its children. Every object has exactly one parent object (except screens), but a parent can have an unlimited number of children. There is no limitation for the type of the parent but, there are typical parent (e.g. button) and typical child (e.g. label) objects."
msgstr ""

#: ../overview/object.md:58
msgid "Moving together"
msgstr ""

#: ../overview/object.md:60
msgid "If the position of the parent is changed the children will move with the parent. Therefore all positions are relative to the parent."
msgstr ""

#: ../overview/object.md:63
msgid "The (0;0) coordinates mean the objects will remain in the top left-hand corner of the parent independently from the position of the parent."
msgstr ""

#: ../overview/object.md:65
msgid "Objects are moving together 1"
msgstr ""

#: ../overview/object.md:75
msgid "Modify the position of the parent:"
msgstr ""

#: ../overview/object.md:77
msgid "Graphical objects are moving together 2"
msgstr ""

#: ../overview/object.md:83
msgid "(For simplicity the adjusting of colors of the objects is not shown in the example.)"
msgstr ""

#: ../overview/object.md:85
msgid "Visibility only on the parent"
msgstr ""

#: ../overview/object.md:87
msgid "If a child is partially or fully out of its parent then the parts outside will not be visible."
msgstr ""

#: ../overview/object.md:89
msgid "A graphical object is visible on its parent"
msgstr ""

#: ../overview/object.md:95
msgid "Create - delete objects"
msgstr ""

#: ../overview/object.md:97
msgid "In LVGL objects can be created and deleted dynamically in run-time. It means only the currently created objects consume RAM. For example, if you need a chart, you can create it when required and delete it when it is not visible or necessary."
msgstr ""

#: ../overview/object.md:101
msgid "Every object type has its own create function with a unified prototype. It needs two parameters:"
msgstr ""

#: ../overview/object.md:103
msgid "A pointer to the parent object. To create a screen give NULL as parent."
msgstr ""

#: ../overview/object.md:104
msgid "Optionally, a pointer to copy object with the same type to copy it. This copy object can be NULL to avoid the copy operation."
msgstr ""

#: ../overview/object.md:106
msgid "All objects are referenced in C code using an lv_obj_t pointer as a handle. This pointer can later be used to set or get the attributes of the object."
msgstr ""

#: ../overview/object.md:108
msgid "The create functions look like this:"
msgstr ""

#: ../overview/object.md:114
msgid "There is a common delete function for all object types. It deletes the object and all of its children."
msgstr ""

#: ../overview/object.md:120
msgid "lv_obj_del will delete the object immediately. If for any reason you can't delete the object immediately you can use lv_obj_del_async(obj). It is useful e.g. if you want to delete the parent of an object in the child's LV_EVENT_DELETE signal."
msgstr ""

#: ../overview/object.md:124
msgid "You can remove all the children of an object (but not the object itself) using lv_obj_clean:"
msgstr ""

#: ../overview/object.md:130
msgid "Screen – the most basic parent"
msgstr ""

#: ../overview/object.md:132
msgid "The screens are special objects which have no parent object. So it is created like:"
msgstr ""

#: ../overview/object.md:137
msgid "There is always an active screen on each display. By default, the library creates and loads a \"Base object\" as the screen for each display.To get the currently active screen use the lv_scr_act() function. To load a new one, use lv_scr_load(scr1)."
msgstr ""

#: ../overview/object.md:140
msgid "Screens can be created with any object type. For example, a Base object or an image to make a wallpaper."
msgstr ""

#: ../overview/object.md:142
msgid "Screens are created on the currently selected default display. The default screen is the last registered screen with lv_disp_drv_register or you can explicitly select a new default display using lv_disp_set_default(disp). lv_scr_act() and lv_scr_load() operate on the currently default screen."
msgstr ""

#: ../overview/object.md:146
msgid "Visit Multi-display support to learn more."
msgstr ""

#: ../overview/object.md:148
#: ../overview/style.md:79
msgid "Parts"
msgstr ""

#: ../overview/object.md:150
msgid "The widgets can have multiple parts. For example a Button has only a main part but a Slider is built from a background, an indicator and a knob."
msgstr ""

#: ../overview/object.md:152
msgid "The name of the parts is constructed like LV_ + <TYPE> _PART_ <NAME>. For example LV_BTN_PART_MAIN or LV_SLIDER_PART_KNOB. The parts are usually used when styles are add to the objects. Using parts different styles can be assigned to the different parts of the objects."
msgstr ""

#: ../overview/object.md:155
msgid "To learn more about the parts read the related section of the Style overview."
msgstr ""

#: ../overview/object.md:157
#: ../overview/style.md:20
msgid "States"
msgstr ""

#: ../overview/object.md:158
msgid "The object can be in a combinations of the following states:"
msgstr ""

#: ../overview/object.md:159
msgid "LV_STATE_DEFAULT  Normal, released"
msgstr ""

#: ../overview/object.md:160
msgid "LV_STATE_CHECKED Toggled or checked"
msgstr ""

#: ../overview/object.md:161
msgid "LV_STATE_FOCUSED Focused via keypad or encoder or clicked via touchpad/mouse"
msgstr ""

#: ../overview/object.md:162
msgid "LV_STATE_EDITED  Edit by an encoder"
msgstr ""

#: ../overview/object.md:163
msgid "LV_STATE_HOVERED Hovered by mouse (not supported now)"
msgstr ""

#: ../overview/object.md:164
msgid "LV_STATE_PRESSED Pressed"
msgstr ""

#: ../overview/object.md:165
msgid "LV_STATE_DISABLED Disabled or inactive"
msgstr ""

#: ../overview/object.md:167
msgid "The states are usually automatically changed by the library as the user presses, releases, focuses etc an object. However, the states can be changed manually too. To completely overwrite the current state use lv_obj_set_state(obj, part, LV_STATE...). To set or clear given state (but leave to other states untouched) use lv_obj_add/clear_state(obj, part, LV_STATE_...) In both cases ORed state values can be used as well. E.g. lv_obj_set_state(obj, part, LV_STATE_PRESSED | LV_PRESSED_CHECKED)."
msgstr ""

#: ../overview/object.md:172
msgid "To learn more about the states read the related section of the Style overview."
msgstr ""

#: ../overview/style.md:5
msgid "Styles"
msgstr ""

#: ../overview/style.md:7
msgid "Styles are used to set the appearance of the objects. Styles in lvgl are heavily inspired by CSS. The concept in nutshell is the following:"
msgstr ""

#: ../overview/style.md:8
msgid "A style is an lv_style_t variable which can hold properties, for example border width, text color and so on. It's similar to class in CSS."
msgstr ""

#: ../overview/style.md:9
msgid "Not all properties have to be specified. Unspecified properties will use a default value."
msgstr ""

#: ../overview/style.md:10
msgid "Styles can be assigned to objects to change their appearance."
msgstr ""

#: ../overview/style.md:11
msgid "A style can be used by any number of objects."
msgstr ""

#: ../overview/style.md:12
msgid "Styles can be cascaded which means multiple styles can be assigned to an object and each style can have different properties.   For example style_btn can result in a default gray button and style_btn_red can add only a background-color=red to overwrite the background color."
msgstr ""

#: ../overview/style.md:14
msgid "Later added styles have higher precedence. It means if a property is specified in two styles the later added will be used."
msgstr ""

#: ../overview/style.md:15
msgid "Some properties (e.g. text color) can be inherited from the parent(s) if it's not specified in the object."
msgstr ""

#: ../overview/style.md:16
msgid "Objects can have local styles that have higher precedence than \"normal\" styles."
msgstr ""

#: ../overview/style.md:17
msgid "Unlike CSS (where pseudo-classes describes different states, e.g. :hover), in lvgl a property is assigned to a given state. (I.e. not the \"class\" is related to state but every single property has a state)"
msgstr ""

#: ../overview/style.md:18
msgid "Transitions can be applied when the object changes state."
msgstr ""

#: ../overview/style.md:21
msgid "The objects can be in the following states:"
msgstr ""

#: ../overview/style.md:22
msgid "LV_STATE_DEFAULT (0x00): Normal, released"
msgstr ""

#: ../overview/style.md:23
msgid "LV_STATE_CHECKED (0x01): Toggled or checked"
msgstr ""

#: ../overview/style.md:24
msgid "LV_STATE_FOCUSED (0x02): Focused via keypad or encoder or clicked via touchpad/mouse"
msgstr ""

#: ../overview/style.md:25
msgid "LV_STATE_EDITED  (0x04): Edit by an encoder"
msgstr ""

#: ../overview/style.md:26
msgid "LV_STATE_HOVERED (0x08): Hovered by mouse (not supported now)"
msgstr ""

#: ../overview/style.md:27
msgid "LV_STATE_PRESSED (0x10): Pressed"
msgstr ""

#: ../overview/style.md:28
msgid "LV_STATE_DISABLED (0x20): Disabled or inactive"
msgstr ""

#: ../overview/style.md:30
msgid "Combination of states is  also possible, for example LV_STATE_FOCUSED | LV_STATE_PRESSED."
msgstr ""

#: ../overview/style.md:32
msgid "The style properties can be defined in every state and state combination. For example, setting a different background color for default and pressed state. If a property is not defined in a state the best matching state's property will be used. Typically it means the property with LV_STATE_DEFAULT state.˛ If the property is not set even for the default state the default value will be used. (See later)"
msgstr ""

#: ../overview/style.md:36
msgid "But what does the \"best matching state's property\" really means? States have a precedence which is shown by their value (see in the above list). A higher value means higher precedence. To determine which state's property to use let's use an example. Let's see the background color is defined like this:"
msgstr ""

#: ../overview/style.md:39
msgid "LV_STATE_DEFAULT: white"
msgstr ""

#: ../overview/style.md:40
msgid "LV_STATE_PRESSED: gray"
msgstr ""

#: ../overview/style.md:41
msgid "LV_STATE_FOCUSED: red"
msgstr ""

#: ../overview/style.md:43
msgid "By the default the object is in default state, so it's a simple case: the property is perfectly defined in the object's current state as white"
msgstr ""

#: ../overview/style.md:44
msgid "When the object is pressed there are 2 related properties: default with white (default is related to every state) and pressed with gray. The pressed state has 0x10 precedence which is higher than the default state's 0x00 precedence, so gray color will be used."
msgstr ""

#: ../overview/style.md:46
msgid "When the object is focused the same thing happens as in pressed state and red color will be used. (Focused state has higher precedence than default state)."
msgstr ""

#: ../overview/style.md:47
msgid "When the object is focused and pressed both gray and red would work, but the pressed state has higher precedence than focused so gray color will be used."
msgstr ""

#: ../overview/style.md:48
msgid "It's possible to set e.g rose color for LV_STATE_PRESSED | LV_STATE_FOCUSED. In this case, this combined state has 0x02 + 0x10 = 0x12 precedence, which higher than the pressed states precedence so rose color would be used."
msgstr ""

#: ../overview/style.md:50
msgid "When the object is checked there is no property to set the background color for this state. So in lack of a better option, the object remains white from the default state's property."
msgstr ""

#: ../overview/style.md:52
msgid "Some practical notes:"
msgstr ""

#: ../overview/style.md:53
msgid "If you want to set a property for all state (e.g. red background color) just set it for the default state. If the object can't find a property for its current state it will fall back to the default state's property."
msgstr ""

#: ../overview/style.md:54
msgid "Use ORed states to describe the properties for complex cases. (E.g. pressed + checked + focused)"
msgstr ""

#: ../overview/style.md:55
msgid "It might be a good idea to use different style elements for different states. For example, finding background colors for released, pressed, checked + pressed, focused, focused + pressed, focused + pressed + checked, etc states is quite difficult. Instead, for example, use the background color for pressed and checked states and indicate the focused state with a different border color."
msgstr ""

#: ../overview/style.md:59
msgid "Cascading styles"
msgstr ""

#: ../overview/style.md:60
msgid "It's not required to set all the properties in one style. It's possible to add more styles to an object and let the later added style to modify or extend the properties in the other styles. For example, create a general gray button style and create a new for red buttons where only the new background color is set."
msgstr ""

#: ../overview/style.md:63
msgid "It's the same concept when in CSS all the used classes are listed like <div class=\".btn .btn-red\">."
msgstr ""

#: ../overview/style.md:65
msgid "The later added styles have higher precedence over the earlier ones. So in the gray/red button example above, the normal button style should be added first and the red style second. However, the precedence coming from states are still taken into account. So let's examine the following case:"
msgstr ""

#: ../overview/style.md:68
msgid "the basic button style defines dark-gray color for default state and light-gray color pressed state"
msgstr ""

#: ../overview/style.md:69
msgid "the red button style defines the background color as red only in the default state"
msgstr ""

#: ../overview/style.md:71
msgid "In this case, when the button is released (it's in default state) it will be red because a perfect match is found in the lastly added style (red style). When the button is pressed the light-gray color is a better match because it describes the current state perfectly, so the button will be light-gray."
msgstr ""

#: ../overview/style.md:74
msgid "Inheritance"
msgstr ""

#: ../overview/style.md:75
msgid "Some properties (typically that are related to texts) can be inherited from the parent object's styles. Inheritance is applied only if the given property is not set in the object's styles (even in default state). In this case, if the property is inheritable, the property's value will be searched in the parent too until a part can tell a value for the property. The parents will use their own state to tell the value. So is button is pressed, and text color comes from here, the pressed text color will be used."
msgstr ""

#: ../overview/style.md:80
msgid "Objects can have parts which can have their own style. For example a page has four parts:"
msgstr ""

#: ../overview/style.md:81
#: ../overview/style.md:418
msgid "Background"
msgstr ""

#: ../overview/style.md:82
msgid "Scrollable"
msgstr ""

#: ../overview/style.md:83
msgid "Scrollbar"
msgstr ""

#: ../overview/style.md:84
msgid "Edge flash"
msgstr ""

#: ../overview/style.md:86
msgid "![page_small.png](A scrollable page in lvgl)"
msgstr ""

#: ../overview/style.md:88
msgid "There is three types of object parts main, virtual and real."
msgstr ""

#: ../overview/style.md:90
msgid "The main part is usually the background and largest part of the object. Some object has only a main part. For example, a button has only a background."
msgstr ""

#: ../overview/style.md:92
msgid "The virtual parts are additional parts just drawn on the fly to the main part. There is no \"real\" object behind them. For example, the page's scrollbar is not a real object, it's just drawn when the page's background is drawn. The virtual parts always have the same state as the main part. If the property can be inherited, the main part will be also considered before going to the parent."
msgstr ""

#: ../overview/style.md:97
msgid "The real parts are real objects created and managed by the main object. For example, the page's scrollable part is real object. Real parts can be in different state than the main part."
msgstr ""

#: ../overview/style.md:100
msgid "To see which parts an object has visit their documentation page."
msgstr ""

#: ../overview/style.md:102
msgid "Initialize styles and set/get properties"
msgstr ""

#: ../overview/style.md:104
msgid "Styles are stored in lv_style_t variables. Style variables should be static, global or dynamically allocated. In other words they can not be local variables in functions which are destroyed when the function exists. Before using a style it should be initialized with lv_style_init(&my_style). After initializing the style properties can be set added to it. Property set functions looks like this: lv_style_set_<property_name>(&style, <state>, <value>); For example the above mentioned example looks like this:"
msgstr ""

#: ../overview/style.md:117
msgid "It's possible to copy a style with lv_style_copy(&style_destination, &style_source). After copy properties still can be added freely."
msgstr ""

#: ../overview/style.md:119
msgid "To remove a property use:"
msgstr ""

#: ../overview/style.md:125
msgid "To get the value from style in a state functions with the following prototype are available: lv_style_get_<prperty_name>(&style, <state>, <result poiner>);. The the best matching property will be selected and it's precedence will be returned. -1 will be returned if the property is not found. For example:"
msgstr ""

#: ../overview/style.md:137
msgid "To reset a style (free all it's data) use"
msgstr ""

#: ../overview/style.md:142
msgid "Managing style list"
msgstr ""

#: ../overview/style.md:143
msgid "A style on its own not that useful. It should be assigned to an object to take its effect. Every part of the objects stores a style list which is the list of assigned styles."
msgstr ""

#: ../overview/style.md:146
msgid "To add a style to an object use lv_obj_add_style(obj, <part>, &style) For example:"
msgstr ""

#: ../overview/style.md:153
msgid "An objects style list can be reset with lv_obj_reset_style_list(obj, <part>)"
msgstr ""

#: ../overview/style.md:155
msgid "If a style which is already assigned to an object changes (i.e. one of it's property is set to a new value) the objects using that style should be notified with lv_obj_refresh_style(obj)"
msgstr ""

#: ../overview/style.md:157
msgid "To get a final value of property, including cascading, inheritance, local styles and transitions (see below), get functions like this can be used: lv_obj_get_style_<property_name>(obj, <part>). These functions uses the object's current state and if no better candidate returns a default value.   For example:"
msgstr ""

#: ../overview/style.md:164
msgid "Local styles"
msgstr ""

#: ../overview/style.md:165
msgid "In the object's style lists, so-called local properties can be stored as well. It's the same concept than CSS's <div style=\"color:red\">. The local style is the same as a normal style, but it belongs only to a given object and can not be shared with other objects. To set a local property use functions like lv_obj_set_style_local_<property_name>(obj, <part>, <state>, <value>);   For example:"
msgstr ""

#: ../overview/style.md:173
msgid "Transitions"
msgstr ""

#: ../overview/style.md:174
msgid "By default, when an object changes state (e.g. it's pressed) the new properties from the new state are set immediately. However, with transitions it's possible to play an animation on state change. For example, on pressing a button its background color can be animated to the pressed color over 300 ms."
msgstr ""

#: ../overview/style.md:177
msgid "The parameters of the transitions are stored in the styles. It's possible to set"
msgstr ""

#: ../overview/style.md:178
msgid "the time of the transition"
msgstr ""

#: ../overview/style.md:179
msgid "the delay before starting the transition"
msgstr ""

#: ../overview/style.md:180
msgid "the animation path (also known as timing function)"
msgstr ""

#: ../overview/style.md:181
msgid "the properties to animate"
msgstr ""

#: ../overview/style.md:183
msgid "The transition properties can be defined for each state. For example, setting 500 ms transition time in default state will mean that when the object goes to default state 500 ms transition time will be applied. Setting 100 ms transition time in the pressed state will mean a 100 ms transition time when going to presses state. So this example configuration will result in fast going to presses state and slow going back to default."
msgstr ""

#: ../overview/style.md:188
msgid "Properties"
msgstr ""

#: ../overview/style.md:190
msgid "The following properties can be used in the styles."
msgstr ""

#: ../overview/style.md:192
msgid "Mixed properties"
msgstr ""

#: ../overview/style.md:193
msgid "radius (lv_style_int_t): Set the radius of the background. 0: no radius, LV_RADIUS_CIRCLE: maximal radius."
msgstr ""

#: ../overview/style.md:194
msgid "clip_corner (bool): true: enable to clip the overflowed content on the rounded (radius > 0) corners."
msgstr ""

#: ../overview/style.md:195
msgid "size (lv_style_int_t): Size of internal elements of the widgets. See the documentation of the widgets if this property is used or not."
msgstr ""

#: ../overview/style.md:196
msgid "transform_width  (lv_style_int_t): Make the object wider on both sides with this value."
msgstr ""

#: ../overview/style.md:197
msgid "transform_height  (lv_style_int_t) Make the object higher on both sides with this value."
msgstr ""

#: ../overview/style.md:198
msgid "opa_scale (lv_style_int_t): Inherited. Scale down all opacity values of the object by this factor. As it's inherited the children objects will be affected too."
msgstr ""

#: ../overview/style.md:200
msgid "Padding and margin properties"
msgstr ""

#: ../overview/style.md:201
msgid "Padding sets the space on the inner sides of the edges. It means \"I don't want my children too close to my sides, so keep this space\".Padding inner set the \"gap\" between the children. Margin sets the space on the outer side of the edges. It means \"I want this space around me\"."
msgstr ""

#: ../overview/style.md:205
msgid "These properties are typically used by Container object if layout or auto fit is enabled. However other widgets also use them to set spacing. See the documentation of the widgets for the details.  - pad_top (lv_style_int_t): Set the padding on the top.  - pad_bottom (lv_style_int_t): Set the padding on the bottom.  - pad_left (lv_style_int_t): Set the padding on the left.  - pad_right (lv_style_int_t): Set the padding on the right.  - pad_inner (lv_style_int_t): Set the padding inside the object between children.  - margin_top (lv_style_int_t): Set the margin on the top.  - margin_bottom (lv_style_int_t): Set the margin on the bottom.  - margin_left (lv_style_int_t): Set the margin on the left.  - margin_right (lv_style_int_t): Set the margin on the right."
msgstr ""

#: ../overview/style.md:218
msgid "Background properties"
msgstr ""

#: ../overview/style.md:219
msgid "The background is a simple rectangle which can have gradient and radius rounding."
msgstr ""

#: ../overview/style.md:220
msgid "bg_color (lv_color_t) Specifies the color of the background. Default value: LV_COLOR_WHITE"
msgstr ""

#: ../overview/style.md:221
msgid "bg_opa (lv_opa_t) Specifies opacity of the background. Default value: LV_OPA_TRANSP."
msgstr ""

#: ../overview/style.md:222
msgid "bg_grad_color (lv_color_t) Specifies the color of the background's gradient. The color on the right or bottom is bg_grad_dir != LV_GRAD_DIR_NONE. Default value: LV_COLOR_WHITE."
msgstr ""

#: ../overview/style.md:223
msgid "bg_main_stop (uint8_t): Specifies where should the gradient start. 0: at left/top most position, 255: at right/bottom most position."
msgstr ""

#: ../overview/style.md:224
msgid "bg_grad_stop (uint8_t): Specifies where should the gradient start. 0: at left/top most position, 255: at right/bottom most position. Default value: 255."
msgstr ""

#: ../overview/style.md:225
msgid "bg_grad_dir (lv_grad_dir_t) Specifies the direction of the gradient. Can be LV_GRAD_DIR_NONE/HOR/VER. Default value: LV_GRAD_DIR_NONE."
msgstr ""

#: ../overview/style.md:226
msgid "bg_blend_mode (lv_blend_mode_t): Set the blend mode the background. Can be LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE). Default value: LV_BLEND_MODE_NORMAL."
msgstr ""

#: ../overview/style.md:236
msgid "Border properties"
msgstr ""

#: ../overview/style.md:237
msgid "The border in drawn on to of the background. It has radius rounding."
msgstr ""

#: ../overview/style.md:238
msgid "border_color (lv_color_t) Specifies the color of the border."
msgstr ""

#: ../overview/style.md:239
msgid "border_opa (lv_opa_t) Specifies opacity of the border."
msgstr ""

#: ../overview/style.md:240
msgid "border_width (lv_style_int_t): Set the width of the border."
msgstr ""

#: ../overview/style.md:241
msgid "border_side (lv_border_side_t) Specifies which sides of the border to draw. Can be LV_BORDER_SIDE_NONE/LEFT/RIGHT/TOP/BOTTOM/FULL. ORed values are also possible. Default value: LV_BORDER_SIDE_FULL."
msgstr ""

#: ../overview/style.md:242
msgid "border_post (bool): If true the border will be drawn all children has been drawn."
msgstr ""

#: ../overview/style.md:243
msgid "border_blend_mode (lv_blend_mode_t): Set the blend mode of the border. Can be LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE). Default value: LV_BLEND_MODE_NORMAL."
msgstr ""

#: ../overview/style.md:253
msgid "Outline properties"
msgstr ""

#: ../overview/style.md:254
msgid "The outline is similar to border but is drawn outside of the object."
msgstr ""

#: ../overview/style.md:255
msgid "outline_color (lv_color_t) Specifies the color of the outline."
msgstr ""

#: ../overview/style.md:256
msgid "outline_opa (lv_opa_t) Specifies opacity of the outline."
msgstr ""

#: ../overview/style.md:257
msgid "outline_width (lv_style_int_t): Set the width of the outline."
msgstr ""

#: ../overview/style.md:258
msgid "outline_pad (lv_style_int_t) Set the space between the object and the outline."
msgstr ""

#: ../overview/style.md:259
msgid "outline_blend_mode (lv_blend_mode_t): Set the blend mode of the outline. Can be LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE). Default value: LV_BLEND_MODE_NORMAL."
msgstr ""

#: ../overview/style.md:269
msgid "Shadow properties"
msgstr ""

#: ../overview/style.md:270
msgid "The shadow is a blurred area under the object."
msgstr ""

#: ../overview/style.md:271
msgid "shadow_color (lv_color_t) Specifies the color of the shadow."
msgstr ""

#: ../overview/style.md:272
msgid "shadow_opa (lv_opa_t) Specifies opacity of the shadow."
msgstr ""

#: ../overview/style.md:273
msgid "shadow_width (lv_style_int_t): Set the width (blur size) of the outline."
msgstr ""

#: ../overview/style.md:274
msgid "shadow_ofs_x (lv_style_int_t): Set the an X offset for the shadow."
msgstr ""

#: ../overview/style.md:275
msgid "shadow_ofs_y (lv_style_int_t): Set the an Y offset for the shadow."
msgstr ""

#: ../overview/style.md:276
msgid "shadow_spread (lv_style_int_t): ake the shadow larger than the background in every direction by this value."
msgstr ""

#: ../overview/style.md:277
msgid "shadow_blend_mode (lv_blend_mode_t): Set the blend mode of the shadow. Can be LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE). Default value: LV_BLEND_MODE_NORMAL."
msgstr ""

#: ../overview/style.md:287
msgid "Pattern properties"
msgstr ""

#: ../overview/style.md:288
msgid "The pattern is an image (or symbol) drawn in the middle of the background or repeated to fill the whole background."
msgstr ""

#: ../overview/style.md:289
msgid "pattern_image (const void *): Pointer to an lv_img_dsc_t variable, a path to an image file or a symbol."
msgstr ""

#: ../overview/style.md:290
msgid "pattern_opa (lv_opa_t): Specifies opacity of the pattern."
msgstr ""

#: ../overview/style.md:291
msgid "pattern_recolor (lv_color_t): Mix this color to the pattern image. In case of symbols (texts) it will be the text color."
msgstr ""

#: ../overview/style.md:292
msgid "pattern_recolor_opa (lv_opa_t): Intensity of recoloring. Default value: LV_OPA_TRANSP (no recoloring)."
msgstr ""

#: ../overview/style.md:293
msgid "pattern_repeat (bool): true: the pattern will be repeated as a mosaic. false: place the pattern in the middle of the background."
msgstr ""

#: ../overview/style.md:294
msgid "pattern_blend_mode (lv_blend_mode_t): Set the blend mode of the pattern. Can be LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE). Default value: LV_BLEND_MODE_NORMAL."
msgstr ""

#: ../overview/style.md:304
msgid "Value properties"
msgstr ""

#: ../overview/style.md:305
msgid "Value is an arbitrary text drawn to the background. It can be a lightweighted replacement of creating label objects."
msgstr ""

#: ../overview/style.md:307
msgid "value_str (const char *): Pointer to text to display. Only the pointer is saved."
msgstr ""

#: ../overview/style.md:308
msgid "value_color (lv_color_t): Color of the text."
msgstr ""

#: ../overview/style.md:309
msgid "value_opa (lv_opa_t): Opacity of the text."
msgstr ""

#: ../overview/style.md:310
msgid "value_font (const lv_font_t *): Pointer to font of the text."
msgstr ""

#: ../overview/style.md:311
msgid "value_letter_space (lv_style_int_t): Letter space of the text."
msgstr ""

#: ../overview/style.md:312
msgid "value_line_space (lv_style_int_t): Line space of the text."
msgstr ""

#: ../overview/style.md:313
msgid "value_align (lv_align_t): Alignment of the text. Can be LV_ALIGN_...."
msgstr ""

#: ../overview/style.md:314
msgid "value_ofs_x (lv_style_int_t): X offset from the original position of the alignment."
msgstr ""

#: ../overview/style.md:315
msgid "value_ofs_y (lv_style_int_t): Y offset from the original position of the alignment."
msgstr ""

#: ../overview/style.md:316
msgid "value_blend_mode (lv_blend_mode_t): Set the blend mode of the text. Can be LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE). Default value: LV_BLEND_MODE_NORMAL."
msgstr ""

#: ../overview/style.md:326
msgid "Text properties"
msgstr ""

#: ../overview/style.md:327
msgid "Properties for textual object."
msgstr ""

#: ../overview/style.md:328
msgid "text_color (lv_color_t): Color of the text."
msgstr ""

#: ../overview/style.md:329
msgid "text_opa (lv_opa_t): Opacity of the text."
msgstr ""

#: ../overview/style.md:330
msgid "text_font (const lv_font_t *): Pointer to font of the text."
msgstr ""

#: ../overview/style.md:331
msgid "text_letter_space (lv_style_int_t): Letter space of the text."
msgstr ""

#: ../overview/style.md:332
msgid "text_line_space (lv_style_int_t): Line space of the text."
msgstr ""

#: ../overview/style.md:333
msgid "text_decor (lv_text_decor_t): Add text decoration. Can be LV_TEXT_DECOR_NONE/UNDERLINE/STRIKETHROUGH."
msgstr ""

#: ../overview/style.md:334
msgid "text_sel_color (lv_color_t): Set background color of text selection."
msgstr ""

#: ../overview/style.md:335
msgid "text_blend_mode (lv_blend_mode_t): Set the blend mode of the text. Can be LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE). Default value: LV_BLEND_MODE_NORMAL."
msgstr ""

#: ../overview/style.md:345
msgid "Line properties"
msgstr ""

#: ../overview/style.md:346
msgid "Properties of lines."
msgstr ""

#: ../overview/style.md:347
msgid "line_color (lv_color_t): Color of the line."
msgstr ""

#: ../overview/style.md:348
msgid "line_opa (lv_opa_t): Opacity of the line."
msgstr ""

#: ../overview/style.md:349
msgid "line_width (lv_style_int_t): Width of the line."
msgstr ""

#: ../overview/style.md:350
msgid "line_dash_width (lv_style_int_t): Width of dash. Dashing is drawn only for horizontal or vertical lines. 0: disable dash."
msgstr ""

#: ../overview/style.md:351
msgid "line_dash_gap (lv_style_int_t): Gap between two dash line. Dashing is drawn only for horizontal or vertical lines. 0: disable dash."
msgstr ""

#: ../overview/style.md:352
msgid "line_rounded (bool): true: draw rounded line endings."
msgstr ""

#: ../overview/style.md:353
msgid "line_blend_mode (lv_blend_mode_t): Set the blend mode of the line. Can be LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE). Default value: LV_BLEND_MODE_NORMAL."
msgstr ""

#: ../overview/style.md:363
msgid "Image properties"
msgstr ""

#: ../overview/style.md:364
msgid "Properties of image."
msgstr ""

#: ../overview/style.md:365
msgid "image_recolor (lv_color_t):  Mix this color to the pattern image. In case of symbols (texts) it will be the text color."
msgstr ""

#: ../overview/style.md:366
msgid "image_recolor_opa (lv_opa_t): Intensity of recoloring. Default value: LV_OPA_TRANSP (no recoloring)."
msgstr ""

#: ../overview/style.md:367
msgid "image_opa (lv_opa_t): Opacity of the image."
msgstr ""

#: ../overview/style.md:368
msgid "image_blend_mode (lv_blend_mode_t): Set the blend mode of the image. Can be LV_BLEND_MODE_NORMAL/ADDITIVE/SUBTRACTIVE). Default value: LV_BLEND_MODE_NORMAL."
msgstr ""

#: ../overview/style.md:378
msgid "Transition properties"
msgstr ""

#: ../overview/style.md:379
msgid "Properties to describe state change animations."
msgstr ""

#: ../overview/style.md:380
msgid "transition_time (lv_style_int_t): Time of the transition."
msgstr ""

#: ../overview/style.md:381
msgid "transition_delay (lv_style_int_t): Delay before the transition."
msgstr ""

#: ../overview/style.md:382
msgid "transition_1 (property name): A property on which transition should be applied. Use the property name with upper case with LV_STYLE_ prefix, e.g. LV_STYLE_BG_COLOR"
msgstr ""

#: ../overview/style.md:383
msgid "transition_2 (property name): Same as transition_1 just for an other property."
msgstr ""

#: ../overview/style.md:384
msgid "transition_3 (property name): Same as transition_1 just for an other property."
msgstr ""

#: ../overview/style.md:385
msgid "transition_4 (property name): Same as transition_1 just for an other property."
msgstr ""

#: ../overview/style.md:386
msgid "transition_5 (property name): Same as transition_1 just for an other property."
msgstr ""

#: ../overview/style.md:387
msgid "transition_6 (property name): Same as transition_1 just for an other property."
msgstr ""

#: ../overview/style.md:388
msgid "transition_path (lv_anim_path_t): An animation path for the transition. (Needs to be static or global variable because only its pointer is saved)."
msgstr ""

#: ../overview/style.md:398
msgid "Scale properties"
msgstr ""

#: ../overview/style.md:399
msgid "Auxiliary properties for scale-like elements. Scales have a normal and end region. As the name implies the end region is the end of the scale where can be critical values or inactive values. The normal region is before the end region. Both regions could have different properties."
msgstr ""

#: ../overview/style.md:402
msgid "scale_grad_color (lv_color_t):  In normal region make gradient to this color on the scale lines."
msgstr ""

#: ../overview/style.md:403
msgid "scale_end_color (lv_color_t):  Color of the scale lines in the end region."
msgstr ""

#: ../overview/style.md:404
msgid "scale_width (lv_style_int_t): Width of the scale. Default value: LV_DPI / 8."
msgstr ""

#: ../overview/style.md:405
msgid "scale_border_width (lv_style_int_t): Width of a border drawn on the outer side of the scale in the normal region."
msgstr ""

#: ../overview/style.md:406
msgid "scale_end_border_width (lv_style_int_t): Width of a border drawn on the outer side of the scale in the end region."
msgstr ""

#: ../overview/style.md:407
msgid "scale_end_line_width (lv_style_int_t): Width of a scale lines in the end region."
msgstr ""

#: ../overview/style.md:417
msgid "It the documentation of the widgets you will see sentences like \"The widget use the typical background properties\". The \"typical background\" properties are:"
msgstr ""

#: ../overview/style.md:419
msgid "Border"
msgstr ""

#: ../overview/style.md:420
msgid "Outline"
msgstr ""

#: ../overview/style.md:421
msgid "Shadow"
msgstr ""

#: ../overview/style.md:422
msgid "Pattern"
msgstr ""

#: ../overview/style.md:423
msgid "Value"
msgstr ""

#: ../overview/style.md:425
msgid "Themes"
msgstr ""

#: ../overview/style.md:426
msgid "Themes are a collection of styles. There is always an active theme whose styles are automatically applied when an object is created. It gives a default appearance to UI which can be modified by adding further styles."
msgstr ""

#: ../overview/style.md:429
msgid "The default theme is set in lv_conf.h with LV_THEME_... defines. Every theme has the following properties"
msgstr ""

#: ../overview/style.md:430
msgid "primary color"
msgstr ""

#: ../overview/style.md:431
msgid "secondary color"
msgstr ""

#: ../overview/style.md:432
msgid "small font"
msgstr ""

#: ../overview/style.md:433
msgid "normal font"
msgstr ""

#: ../overview/style.md:434
msgid "subtitle font"
msgstr ""

#: ../overview/style.md:435
msgid "title font"
msgstr ""

#: ../overview/style.md:436
msgid "flags (specific to the given theme)"
msgstr ""

#: ../overview/style.md:438
msgid "It up to the theme how to use these properties."
msgstr ""

#: ../overview/style.md:440
msgid "There are 3 built-in themes:"
msgstr ""

#: ../overview/style.md:441
msgid "empty: no default styles are added"
msgstr ""

#: ../overview/style.md:442
msgid "material: an impressive, modern theme - mono: simple black and white theme for monochrome displays"
msgstr ""

#: ../overview/style.md:443
msgid "template: a very simple theme which can be copied to create a custom theme"
msgstr ""

#: ../overview/style.md:445
msgid "Example"
msgstr ""

#: ../overview/style.md:447
msgid "Styling a button"
msgstr ""

#: ../overview/task.md:5
msgid "Tasks"
msgstr ""

#: ../overview/task.md:7
msgid "LVGL has a built-in task system. You can register a function to have it be called periodically. The tasks are handled and called in lv_task_handler(), which needs to be called periodically every few milliseconds. See Porting for more information."
msgstr ""

#: ../overview/task.md:10
msgid "The tasks are non-preemptive, which means a task cannot interrupt another task. Therefore, you can call any LVGL related function in a task."
msgstr ""

#: ../overview/task.md:12
msgid "Create a task"
msgstr ""

#: ../overview/task.md:13
msgid "To create a new task, use lv_task_create(task_cb, period_ms, LV_TASK_PRIO_OFF/LOWEST/LOW/MID/HIGH/HIGHEST, user_data). It will create an lv_task_t * variable, which can be used later to modify the parameters of the task. lv_task_create_basic() can also be used. It allows you to create a new task without specifying any parameters."
msgstr ""

#: ../overview/task.md:16
msgid "A task callback should have void (*lv_task_cb_t)(lv_task_t *); prototype."
msgstr ""

#: ../overview/task.md:18
#: ../overview/task.md:67
msgid "For example:"
msgstr ""

#: ../overview/task.md:40
msgid "Ready and Reset"
msgstr ""

#: ../overview/task.md:42
msgid "lv_task_ready(task) makes the task run on the next call of lv_task_handler()."
msgstr ""

#: ../overview/task.md:44
msgid "lv_task_reset(task) resets the period of a task. It will be called again after the defined period of milliseconds has elapsed."
msgstr ""

#: ../overview/task.md:46
msgid "Set parameters"
msgstr ""

#: ../overview/task.md:47
msgid "You can modify some parameters of the tasks later:"
msgstr ""

#: ../overview/task.md:48
msgid "lv_task_set_cb(task, new_cb)"
msgstr ""

#: ../overview/task.md:49
msgid "lv_task_set_period(task, new_period)"
msgstr ""

#: ../overview/task.md:50
msgid "lv_task_set_prio(task, new_priority)"
msgstr ""

#: ../overview/task.md:52
msgid "One-shot tasks"
msgstr ""

#: ../overview/task.md:54
msgid "You can make a task to run only once by callinglv_task_once(task). The task will automatically be deleted after being called for the first time."
msgstr ""

#: ../overview/task.md:56
msgid "Measure idle time"
msgstr ""

#: ../overview/task.md:58
msgid "You can get the idle percentage time lv_task_handler with lv_task_get_idle(). Note that, it doesn't measure the idle time of the overall system, only lv_task_handler. It can be misleading if you use an operating system and call lv_task_handler in an  task, as it won't actually measure the time the OS spends in an idle thread."
msgstr ""

#: ../overview/task.md:61
msgid "Asynchronous calls"
msgstr ""

#: ../overview/task.md:63
msgid "In some cases, you can't do an action immediately. For example, you can't delete an object right now because something else is still using it or you don't want to block the execution now. For these cases, you can use the lv_async_call(my_function, data_p) to make my_function be called on the next call of lv_task_handler. data_p will be passed to function when it's called. Note that, only the pointer of the data is saved so you need to ensure that the variable will be \"alive\" while the function is called. You can use static, global or dynamically allocated data."
msgstr ""

#: ../overview/task.md:88
msgid "If you just want to delete an object, and don't need to clean anything up in my_screen_cleanup, you could just use lv_obj_del_async, which will delete the object on the next call to lv_task_handler."
msgstr ""

