# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, LVGL LLC
# This file is distributed under the same license as the LVGL package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LVGL v7.3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-08-04 10:16+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../porting/display.md:5
msgid "Display interface"
msgstr ""

#: ../porting/display.md:7
msgid "To set up a display an lv_disp_buf_t and an lv_disp_drv_t variable has to be initialized."
msgstr ""

#: ../porting/display.md:8
msgid "lv_disp_buf_t contains internal graphics buffer(s)."
msgstr ""

#: ../porting/display.md:9
msgid "lv_disp_drv_t contains callback functions to interact with the display and manipulate drawing related things."
msgstr ""

#: ../porting/display.md:11
msgid "Display buffer"
msgstr ""

#: ../porting/display.md:13
msgid "lv_disp_buf_t can be initialized like this:"
msgstr ""

#: ../porting/display.md:26
msgid "There are 3 possible configurations regarding the buffer size:"
msgstr ""

#: ../porting/display.md:27
msgid "One buffer LVGL draws the content of the screen into a buffer and sends it to the display. The buffer can be smaller than the screen. In this case, the larger areas will be redrawn in multiple parts. If only small areas changes (e.g. button press) then only those areas will be refreshed."
msgstr ""

#: ../porting/display.md:30
msgid "Two non-screen-sized buffers having two buffers LVGL can draw into one buffer while the content of the other buffer is sent to display in the background. DMA or other hardware should be used to transfer the data to the display to let the CPU draw meanwhile. This way the rendering and refreshing of the display become parallel. Similarly to the One buffer, LVGL will draw the display's content in chunks if the buffer is smaller than the area to refresh."
msgstr ""

#: ../porting/display.md:34
msgid "Two screen-sized buffers. In contrast to Two non-screen-sized buffers LVGL will always provide the whole screen's content not only chunks. This way the driver can simply change the address of the frame buffer to the buffer received from LVGL. Therefore this method works the best when the MCU has an LCD/TFT interface and the frame buffer is just a location in the RAM."
msgstr ""

#: ../porting/display.md:39
msgid "Display driver"
msgstr ""

#: ../porting/display.md:41
msgid "Once the buffer initialization is ready the display drivers need to be initialized. In the most simple case only the following two fields of lv_disp_drv_t needs to be set:"
msgstr ""

#: ../porting/display.md:42
msgid "buffer pointer to an initialized lv_disp_buf_t variable."
msgstr ""

#: ../porting/display.md:43
msgid "flush_cb a callback function to copy a buffer's content to a specific area of the display."
msgstr ""

#: ../porting/display.md:45
msgid "There are some optional data fields:"
msgstr ""

#: ../porting/display.md:46
msgid "hor_res horizontal resolution of the display. (LV_HOR_RES_MAX by default from lv_conf.h)."
msgstr ""

#: ../porting/display.md:47
msgid "ver_res vertical resolution of the display. (LV_VER_RES_MAX by default from lv_conf.h)."
msgstr ""

#: ../porting/display.md:48
msgid "color_chroma_key a color which will be drawn as transparent on chrome keyed images. LV_COLOR_TRANSP by default from lv_conf.h)."
msgstr ""

#: ../porting/display.md:49
msgid "user_data custom user data for the driver. Its type can be modified in lv_conf.h."
msgstr ""

#: ../porting/display.md:50
msgid "anti-aliasing use anti-aliasing (edge smoothing). LV_ANTIALIAS by default  from lv_conf.h."
msgstr ""

#: ../porting/display.md:51
msgid "rotated if 1 swap hor_res and ver_res. LVGL draws in the same direction in both cases (in lines from top to bottom) so the driver also needs to be reconfigured to change the display's fill direction."
msgstr ""

#: ../porting/display.md:52
msgid "screen_transp if 1 the screen can have transparent or opaque style. LV_COLOR_SCREEN_TRANSP needs to enabled in lv_conf.h."
msgstr ""

#: ../porting/display.md:54
msgid "To use a GPU the following callbacks can be used:"
msgstr ""

#: ../porting/display.md:55
msgid "gpu_fill_cb fill an area in memory with colors."
msgstr ""

#: ../porting/display.md:56
msgid "gpu_blend_cb blend two memory buffers using opacity."
msgstr ""

#: ../porting/display.md:58
msgid "Note that, these functions need to draw to the memory (RAM) and not your display directly."
msgstr ""

#: ../porting/display.md:60
msgid "Some other optional callbacks to make easier and more optimal to work with monochrome, grayscale or other non-standard RGB displays:"
msgstr ""

#: ../porting/display.md:61
msgid "rounder_cb round the coordinates of areas to redraw. E.g. a 2x2 px can be converted to 2x8. It can be used if the display controller can refresh only areas with specific height or width (usually 8 px height with monochrome displays)."
msgstr ""

#: ../porting/display.md:63
msgid "set_px_cb a custom function to write the display buffer. It can be used to store the pixels more compactly if the display has a special color format. (e.g. 1-bit monochrome, 2-bit grayscale etc.) This way the buffers used in lv_disp_buf_t can be smaller to hold only the required number of bits for the given area size. set_px_cb is not working with Two screen-sized buffers display buffer configuration."
msgstr ""

#: ../porting/display.md:66
msgid "monitor_cb a callback function tells how many pixels were refreshed in how much time."
msgstr ""

#: ../porting/display.md:68
msgid "To set the fields of lv_disp_drv_t variable it needs to be initialized with lv_disp_drv_init(&disp_drv). And finally to register a display for LVGL lv_disp_drv_register(&disp_drv) needs to be called."
msgstr ""

#: ../porting/display.md:71
msgid "All together it looks like this:"
msgstr ""

#: ../porting/display.md:81
msgid "Here some simple examples of the callbacks:"
msgstr ""

#: ../porting/display.md:145
#: ../porting/indev.md:190
#: ../porting/tick.md:26
msgid "API"
msgstr ""

#: ../porting/display.md:0
#: ../porting/indev.md:0
msgid "Typedefs"
msgstr ""

#: ../porting/display.md:0
#: ../porting/indev.md:0
msgid "Enums"
msgstr ""

#: ../porting/display.md:0
#: ../porting/indev.md:0
#: ../porting/tick.md:0
msgid "Functions"
msgstr ""

#: ../porting/display.md:0
#: ../porting/display.md:0
#: ../porting/display.md:0
#: ../porting/indev.md:0
#: ../porting/indev.md:0
#: ../porting/indev.md:0
#: ../porting/indev.md:0
msgid "Public Members"
msgstr ""

#: ../porting/indev.md:5
msgid "Input device interface"
msgstr ""

#: ../porting/indev.md:7
msgid "Types of input devices"
msgstr ""

#: ../porting/indev.md:9
msgid "To set up an input device an lv_indev_drv_t variable has to be initialized:"
msgstr ""

#: ../porting/indev.md:20
msgid "type can be"
msgstr ""

#: ../porting/indev.md:21
msgid "LV_INDEV_TYPE_POINTER touchpad or mouse"
msgstr ""

#: ../porting/indev.md:22
msgid "LV_INDEV_TYPE_KEYPAD keyboard or keypad"
msgstr ""

#: ../porting/indev.md:23
msgid "LV_INDEV_TYPE_ENCODER encoder with left, right, push options"
msgstr ""

#: ../porting/indev.md:24
msgid "LV_INDEV_TYPE_BUTTON external buttons pressing the screen"
msgstr ""

#: ../porting/indev.md:26
msgid "read_cb is a function pointer which will be called periodically to report the current state of an input device. It can also buffer data and return false when no more data to be read or true when the buffer is not empty."
msgstr ""

#: ../porting/indev.md:29
msgid "Visit Input devices to learn more about input devices in general."
msgstr ""

#: ../porting/indev.md:31
msgid "Touchpad, mouse or any pointer"
msgstr ""

#: ../porting/indev.md:32
msgid "Input devices which can click points of the screen belong to this category."
msgstr ""

#: ../None:1
msgid "Touchpad drivers must return the last X/Y coordinates even when the state is *LV_INDEV_STATE_REL*."
msgstr ""

#: ../porting/indev.md:52
msgid "To set a mouse cursor use lv_indev_set_cursor(my_indev, &img_cursor). (my_indev is the return value of lv_indev_drv_register)"
msgstr ""

#: ../porting/indev.md:54
msgid "Keypad or keyboard"
msgstr ""

#: ../porting/indev.md:56
msgid "Full keyboards with all the letters or simple keypads with a few navigation buttons belong here."
msgstr ""

#: ../porting/indev.md:58
msgid "To use a keyboard/keypad:"
msgstr ""

#: ../porting/indev.md:59
msgid "Register a read_cb function with LV_INDEV_TYPE_KEYPAD type."
msgstr ""

#: ../porting/indev.md:60
msgid "Enable LV_USE_GROUP in lv_conf.h"
msgstr ""

#: ../porting/indev.md:61
msgid "An object group has to be created: lv_group_t * g = lv_group_create()  and objects have to be added to it with lv_group_add_obj(g, obj)"
msgstr ""

#: ../porting/indev.md:62
msgid "The created group has to be assigned to an input device: lv_indev_set_group(my_indev, g) (my_indev is the return value of lv_indev_drv_register)"
msgstr ""

#: ../porting/indev.md:63
msgid "Use LV_KEY_... to navigate among the objects in the group. See lv_core/lv_group.h for the available keys."
msgstr ""

#: ../porting/indev.md:81
msgid "Encoder"
msgstr ""

#: ../porting/indev.md:82
msgid "With an encoder you can do 4 things:"
msgstr ""

#: ../porting/indev.md:83
msgid "Press its button"
msgstr ""

#: ../porting/indev.md:84
msgid "Long-press its button"
msgstr ""

#: ../porting/indev.md:85
msgid "Turn left"
msgstr ""

#: ../porting/indev.md:86
msgid "Turn right"
msgstr ""

#: ../porting/indev.md:88
msgid "In short, the Encoder input devices work like this:"
msgstr ""

#: ../porting/indev.md:89
msgid "By turning the encoder you can focus on the next/previous object."
msgstr ""

#: ../porting/indev.md:90
msgid "When you press the encoder on a simple object (like a button), it will be clicked."
msgstr ""

#: ../porting/indev.md:91
msgid "If you press the encoder on a complex object (like a list, message box, etc.) the object will go to edit mode whereby turning the encoder you can navigate inside the object."
msgstr ""

#: ../porting/indev.md:92
msgid "To leave edit mode press long the button."
msgstr ""

#: ../porting/indev.md:94
msgid "To use an Encoder (similarly to the Keypads) the objects should be added to groups."
msgstr ""

#: ../porting/indev.md:111
msgid "Using buttons with Encoder logic"
msgstr ""

#: ../porting/indev.md:112
msgid "In addition to standard encoder behavior, you can also utilise its logic to navigate(focus) and edit widgets using buttons. This is especially handy if you have only few buttons avalible, or you want to use other buttons in addition to encoder wheel."
msgstr ""

#: ../porting/indev.md:115
msgid "You need to have 3 buttons avalible:"
msgstr ""

#: ../porting/indev.md:116
msgid "LV_KEY_ENTER will simulate press or pushing of the encoder button"
msgstr ""

#: ../porting/indev.md:117
msgid "LV_KEY_LEFT will simulate turnuing encoder left"
msgstr ""

#: ../porting/indev.md:118
msgid "LV_KEY_RIGHT will simulate turnuing encoder right"
msgstr ""

#: ../porting/indev.md:119
msgid "other keys will be passed to the focused widget"
msgstr ""

#: ../porting/indev.md:121
msgid "If you hold the keys it will simulate encoder click with period specified in indev_drv.long_press_rep_time."
msgstr ""

#: ../porting/indev.md:143
msgid "Button"
msgstr ""

#: ../porting/indev.md:144
msgid "Buttons mean external \"hardware\" buttons next to the screen which are assigned to specific coordinates of the screen. If a button is pressed it will simulate the pressing on the assigned coordinate. (Similarly to a touchpad)"
msgstr ""

#: ../porting/indev.md:147
msgid "To assign buttons to coordinates use lv_indev_set_button_points(my_indev, points_array).points_array should look like const lv_point_t points_array[] =  { {12,30},{60,90}, ...}"
msgstr ""

#: ../None:1
msgid "The points_array can't go out of scope. Either declare it as a global variable or as a static variable inside a function."
msgstr ""

#: ../porting/indev.md:175
msgid "Other features"
msgstr ""

#: ../porting/indev.md:177
msgid "Besides read_cb a feedback_cb callback can be also specified in lv_indev_drv_t. feedback_cb is called when any type of event is sent by the input devices. (independently from its type). It allows making feedback for the user e.g. to play a sound on LV_EVENT_CLICK."
msgstr ""

#: ../porting/indev.md:180
msgid "The default value of the following parameters can be set in lv_conf.h but the default value can be overwritten in lv_indev_drv_t:"
msgstr ""

#: ../porting/indev.md:181
msgid "drag_limit Number of pixels to slide before actually drag the object"
msgstr ""

#: ../porting/indev.md:182
msgid "drag_throw  Drag throw slow-down in [%]. Greater value means faster slow-down"
msgstr ""

#: ../porting/indev.md:183
msgid "long_press_time Press time to send LV_EVENT_LONG_PRESSED (in milliseconds)"
msgstr ""

#: ../porting/indev.md:184
msgid "long_press_rep_time Interval of sending LV_EVENT_LONG_PRESSED_REPEAT (in milliseconds)"
msgstr ""

#: ../porting/indev.md:185
msgid "read_task pointer to the lv_task which reads the input device. Its parameters can be changed by lv_task_...() functions"
msgstr ""

#: ../porting/indev.md:187
msgid "Every Input device is associated with a display. By default, a new input device is added to the lastly created or the explicitly selected (using lv_disp_set_default()) display. The associated display is stored and can be changed in disp field of the driver."
msgstr ""

#: ../porting/index.md:6
msgid "Porting"
msgstr ""

#: ../porting/log.md:5
msgid "Logging"
msgstr ""

#: ../porting/log.md:7
msgid "LVGL has built-in log module to inform the user about what is happening in the library."
msgstr ""

#: ../porting/log.md:9
msgid "Log level"
msgstr ""

#: ../porting/log.md:10
msgid "To enable logging, set LV_USE_LOG  1 in lv_conf.h and set LV_LOG_LEVEL to one of the following values:"
msgstr ""

#: ../porting/log.md:11
msgid "LV_LOG_LEVEL_TRACE A lot of logs to give detailed information"
msgstr ""

#: ../porting/log.md:12
msgid "LV_LOG_LEVEL_INFO  Log important events"
msgstr ""

#: ../porting/log.md:13
msgid "LV_LOG_LEVEL_WARN  Log if something unwanted happened but didn't cause a problem"
msgstr ""

#: ../porting/log.md:14
msgid "LV_LOG_LEVEL_ERROR Only critical issue, when the system may fail"
msgstr ""

#: ../porting/log.md:15
msgid "LV_LOG_LEVEL_NONE  Do not log anything"
msgstr ""

#: ../porting/log.md:17
msgid "The events which have a higher level than the set log level will be logged too. E.g. if you LV_LOG_LEVEL_WARN, errors will be also logged."
msgstr ""

#: ../porting/log.md:19
msgid "Logging with printf"
msgstr ""

#: ../porting/log.md:20
msgid "If your system supports printf, you just need to enable LV_LOG_PRINTF in lv_conf.h to send the logs with printf."
msgstr ""

#: ../porting/log.md:22
msgid "Custom log function"
msgstr ""

#: ../porting/log.md:23
msgid "If you can't use printf or want to use a custom function to log, you can register a \"logger\" callback with lv_log_register_print_cb()."
msgstr ""

#: ../porting/log.md:25
msgid "For example:"
msgstr ""

#: ../porting/log.md:57
msgid "Add logs"
msgstr ""

#: ../porting/log.md:59
msgid "You can also use the log module via the LV_LOG_TRACE/INFO/WARN/ERROR(description) functions."
msgstr ""

#: ../porting/os.md:5
msgid "Operating system and interrupts"
msgstr ""

#: ../porting/os.md:7
msgid "LVGL is not thread-safe by default."
msgstr ""

#: ../porting/os.md:9
msgid "However, in the following conditions it's valid to call LVGL related functions:"
msgstr ""

#: ../porting/os.md:10
msgid "In events. Learn more in Events."
msgstr ""

#: ../porting/os.md:11
msgid "In lv_tasks. Learn more in Tasks."
msgstr ""

#: ../porting/os.md:13
msgid "Tasks and threads"
msgstr ""

#: ../porting/os.md:14
msgid "If you need to use real tasks or threads, you need a mutex which should be invoked before the call of lv_task_handler and released after it. Also, you have to use the same mutex in other tasks and threads around every LVGL (lv_...) related function calls and codes. This way you can use LVGL in a real multitasking environment. Just make use of a mutex to avoid the concurrent calling of LVGL functions."
msgstr ""

#: ../porting/os.md:18
msgid "Interrupts"
msgstr ""

#: ../porting/os.md:19
msgid "Try to avoid calling LVGL functions from the interrupts (except lv_tick_inc() and lv_disp_flush_ready()). But, if you need to do this you have to disable the interrupt which uses LVGL functions while lv_task_handler is running. It's a better approach to set a flag or some value and periodically check it in an lv_task."
msgstr ""

#: ../porting/project.md:6
msgid "Set-up a project"
msgstr ""

#: ../porting/project.md:8
msgid "Get the library"
msgstr ""

#: ../porting/project.md:10
msgid "LVGL Graphics Library is available on GitHub: https://github.com/lvgl/lvgl."
msgstr ""

#: ../porting/project.md:12
msgid "You can clone it or download the latest version of the library from GitHub."
msgstr ""

#: ../porting/project.md:14
msgid "The graphics library is the lvgl directory which should be copied into your project."
msgstr ""

#: ../porting/project.md:16
msgid "Configuration file"
msgstr ""

#: ../porting/project.md:18
msgid "There is a configuration header file for LVGL called lv_conf.h. It sets the library's basic behaviour, disables unused modules and features, adjusts the size of memory buffers in compile-time, etc."
msgstr ""

#: ../porting/project.md:20
msgid "Copy lvgl/lv_conf_template.h next to the lvgl directory and rename it to lv_conf.h. Open the file and change the #if 0 at the beginning to #if 1 to enable its content."
msgstr ""

#: ../porting/project.md:22
msgid "lv_conf.h can be copied other places as well but then you should add LV_CONF_INCLUDE_SIMPLE define to your compiler options (e.g. -DLV_CONF_INCLUDE_SIMPLE for gcc compiler) and set the include path manually."
msgstr ""

#: ../porting/project.md:24
msgid "In the config file comments explain the meaning of the options. Check at least these three configuration options and modify them according to your hardware:"
msgstr ""

#: ../porting/project.md:25
msgid "LV_HOR_RES_MAX Your display's horizontal resolution."
msgstr ""

#: ../porting/project.md:26
msgid "LV_VER_RES_MAX Your display's vertical resolution."
msgstr ""

#: ../porting/project.md:27
msgid "LV_COLOR_DEPTH 8 for (RG332), 16 for (RGB565) or 32 for (RGB888 and ARGB8888)."
msgstr ""

#: ../porting/project.md:29
msgid "Initialization"
msgstr ""

#: ../porting/project.md:31
msgid "To use the graphics library you have to initialize it and the other components too. The order of the initialization is:"
msgstr ""

#: ../porting/project.md:33
msgid "Call lv_init()."
msgstr ""

#: ../porting/project.md:34
msgid "Initialize your drivers."
msgstr ""

#: ../porting/project.md:35
msgid "Register the display and input devices drivers in LVGL.  More about Display and Input device registration."
msgstr ""

#: ../porting/project.md:36
msgid "Call lv_tick_inc(x) in every x milliseconds in an interrupt to tell the elapsed time. Learn more."
msgstr ""

#: ../porting/project.md:37
msgid "Call lv_task_handler() periodically in every few milliseconds to handle LVGL related tasks. Learn more."
msgstr ""

#: ../porting/sleep.md:5
msgid "Sleep management"
msgstr ""

#: ../porting/sleep.md:7
msgid "The MCU can go to sleep when no user input happens. In this case, the main while(1) should look like this:"
msgstr ""

#: ../porting/sleep.md:24
msgid "You should also add below lines to your input device read function if a wake-up (press, touch or click etc.) happens:"
msgstr ""

#: ../porting/sleep.md:31
msgid "In addition to lv_disp_get_inactive_time() you can check lv_anim_count_running() to see if every animations are finished."
msgstr ""

#: ../porting/sys.md:5
msgid "System overview"
msgstr ""

#: ../porting/sys.md:7
msgid "System architecture with LVGL (formerly LittlevGL)"
msgstr ""

#: ../porting/sys.md:9
msgid "Application Your application which creates the GUI and handles the specific tasks."
msgstr ""

#: ../porting/sys.md:12
msgid "LVGL The graphics library itself. Your application can communicate with the library to create a GUI. It contains a HAL (Hardware Abstraction Layer) interface to register your display and input device drivers."
msgstr ""

#: ../porting/sys.md:15
msgid "Driver Besides your specific drivers, it contains functions to drive your display, optionally to a GPU and to read the touchpad or buttons."
msgstr ""

#: ../porting/sys.md:20
msgid "Depending on the MCU, there are two typical hardware set-ups. One with built-in LCD/TFT driver periphery and another without it. In both cases, a frame buffer will be required to store the current image of the screen."
msgstr ""

#: ../porting/sys.md:22
msgid "MCU with TFT/LCD driver If your MCU has a TFT/LCD driver periphery then you can connect a display directly via RGB interface. In this case, the frame buffer can be in the internal RAM (if the MCU has enough RAM) or in the external RAM (if the MCU has a memory interface)."
msgstr ""

#: ../porting/sys.md:26
msgid "External display controller If the MCU doesn't have TFT/LCD driver interface then an external display controller (E.g. SSD1963, SSD1306, ILI9341) has to be used. In this case, the MCU can communicate with the display controller via Parallel port, SPI or sometimes I2C. The frame buffer is usually located in the display controller which saves a lot of RAM for the MCU."
msgstr ""

#: ../porting/task-handler.md:5
msgid "Task Handler"
msgstr ""

#: ../porting/task-handler.md:7
msgid "To handle the tasks of LVGL you need to call lv_task_handler() periodically in one of the followings:"
msgstr ""

#: ../porting/task-handler.md:8
msgid "while(1) of main() function"
msgstr ""

#: ../porting/task-handler.md:9
msgid "timer interrupt periodically (low priority then lv_tick_inc())"
msgstr ""

#: ../porting/task-handler.md:10
msgid "an OS task periodically"
msgstr ""

#: ../porting/task-handler.md:12
msgid "The timing is not critical but it should be about 5 milliseconds to keep the system responsive."
msgstr ""

#: ../porting/task-handler.md:14
msgid "Example:"
msgstr ""

#: ../porting/task-handler.md:22
msgid "To learn more about task visit the Tasks section."
msgstr ""

#: ../porting/tick.md:5
msgid "Tick interface"
msgstr ""

#: ../porting/tick.md:7
msgid "The LVGL needs a system tick to know the elapsed time for animation and other tasks."
msgstr ""

#: ../porting/tick.md:9
msgid "You need to call the lv_tick_inc(tick_period) function periodically and tell the call period in milliseconds. For example, lv_tick_inc(1) for calling in every millisecond."
msgstr ""

#: ../porting/tick.md:11
msgid "lv_tick_inc should be called in a higher priority routine than lv_task_handler() (e.g. in an interrupt) to precisely know the elapsed milliseconds even if the execution of lv_task_handler takes longer time."
msgstr ""

#: ../porting/tick.md:13
msgid "With FreeRTOS lv_tick_inc can be called in vApplicationTickHook."
msgstr ""

#: ../porting/tick.md:15
msgid "On Linux based operating system (e.g. on Raspberry Pi) lv_tick_inc can be called in a thread as below:"
msgstr ""
